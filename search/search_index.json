{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prerequisite It is recommended that you have the latest version of the R environment installed. You need to install devtools and load it into the R environment, and then you can install circlizePlus from Github. install.packages(\"devtools\") library(devtools) install_github(\"TianzeLab/circlizePlus\") Every time you reboot the R environment, you need to load circlizePlus again. library(circlizePlus)","title":"Prerequisite"},{"location":"#prerequisite","text":"It is recommended that you have the latest version of the R environment installed. You need to install devtools and load it into the R environment, and then you can install circlizePlus from Github. install.packages(\"devtools\") library(devtools) install_github(\"TianzeLab/circlizePlus\") Every time you reboot the R environment, you need to load circlizePlus again. library(circlizePlus)","title":"Prerequisite"},{"location":"01-introduction/","text":"Introduction A quick glance set.seed(999) n = 1000 df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE), x = rnorm(n), y = runif(n)) library(circlizePlus) par1=ccPar(\"track.height\" = 0.1) cc=ccPlot(sectors = df$sectors, x = df$x) + par1 track1 = ccTrack(sectors = df$sectors, y = df$y, panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + mm_y(5), CELL_META$sector.index) circos.axis(labels.cex = 0.6) }) col = rep(c(\"#FF0000\", \"#00FF00\"), 4) tackPoint1 = ccTrackPoints(sectors = df$sectors, x = df$x, y = df$y, col = col, pch = 16, cex = 0.5) cell1 = ccCell(sector.index = 'a') + ccText(-1, 0.5, \"text\") track1 = track1 + cell1 + tackPoint1 cc = cc + track1 cc First example of circlize, add the first track. bgcol = rep(c(\"#EFEFEF\", \"#CCCCCC\"), 4) track2 = ccTrackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA) cc = cc + track2 cc First example of circlize, add the second track. track3 = ccTrack(df$sectors, x = df$x, y = df$y, panel.fun = function(x, y) { ind = sample(length(x), 10) x2 = x[ind] y2 = y[ind] od = order(x2) circos.lines(x2[od], y2[od]) }) cc = cc + track3 cc First example of circlize, add the third track. track4 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { xlim = CELL_META$xlim ylim = CELL_META$ylim breaks = seq(xlim[1], xlim[2], by = 0.1) n_breaks = length(breaks) circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1), breaks[-1], rep(ylim[2], n_breaks - 1), col = rand_color(n_breaks), border = NA) }) cc = cc + track4 cc First example of circlize, add the fourth track. link1 = ccLink(\"a\", 0, \"b\", 0, h = 0.4) link2 = ccLink(\"c\", c(-0.5, 0.5), \"d\", c(-0.5,0.5), col = \"red\", border = \"blue\", h = 0.2) link3 = ccLink(\"e\", 0, \"g\", c(-1,1), col = \"green\", border = \"black\", lwd = 2, lty = 2) cc = cc + link1 + link2 + link3 cc First example of circlize, add links. circos.update(sector.index = \"d\", track.index = 2, bg.col = \"#FF8080\", bg.border = \"black\") circos.points(x = -2:2, y = rep(0.5, 5), col = \"white\") circos.text(CELL_META$xcenter, CELL_META$ycenter, \"updated\", col = \"white\") First example of circlize, update the second track. circos.clear()","title":"Introduction"},{"location":"01-introduction/#introduction","text":"","title":"Introduction"},{"location":"01-introduction/#a-quick-glance","text":"set.seed(999) n = 1000 df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE), x = rnorm(n), y = runif(n)) library(circlizePlus) par1=ccPar(\"track.height\" = 0.1) cc=ccPlot(sectors = df$sectors, x = df$x) + par1 track1 = ccTrack(sectors = df$sectors, y = df$y, panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + mm_y(5), CELL_META$sector.index) circos.axis(labels.cex = 0.6) }) col = rep(c(\"#FF0000\", \"#00FF00\"), 4) tackPoint1 = ccTrackPoints(sectors = df$sectors, x = df$x, y = df$y, col = col, pch = 16, cex = 0.5) cell1 = ccCell(sector.index = 'a') + ccText(-1, 0.5, \"text\") track1 = track1 + cell1 + tackPoint1 cc = cc + track1 cc First example of circlize, add the first track. bgcol = rep(c(\"#EFEFEF\", \"#CCCCCC\"), 4) track2 = ccTrackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA) cc = cc + track2 cc First example of circlize, add the second track. track3 = ccTrack(df$sectors, x = df$x, y = df$y, panel.fun = function(x, y) { ind = sample(length(x), 10) x2 = x[ind] y2 = y[ind] od = order(x2) circos.lines(x2[od], y2[od]) }) cc = cc + track3 cc First example of circlize, add the third track. track4 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { xlim = CELL_META$xlim ylim = CELL_META$ylim breaks = seq(xlim[1], xlim[2], by = 0.1) n_breaks = length(breaks) circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1), breaks[-1], rep(ylim[2], n_breaks - 1), col = rand_color(n_breaks), border = NA) }) cc = cc + track4 cc First example of circlize, add the fourth track. link1 = ccLink(\"a\", 0, \"b\", 0, h = 0.4) link2 = ccLink(\"c\", c(-0.5, 0.5), \"d\", c(-0.5,0.5), col = \"red\", border = \"blue\", h = 0.2) link3 = ccLink(\"e\", 0, \"g\", c(-1,1), col = \"green\", border = \"black\", lwd = 2, lty = 2) cc = cc + link1 + link2 + link3 cc First example of circlize, add links. circos.update(sector.index = \"d\", track.index = 2, bg.col = \"#FF8080\", bg.border = \"black\") circos.points(x = -2:2, y = rep(0.5, 5), col = \"white\") circos.text(CELL_META$xcenter, CELL_META$ycenter, \"updated\", col = \"white\") First example of circlize, update the second track. circos.clear()","title":"A quick glance"},{"location":"02-circlize-layout/","text":"Circular layout Other utilities library(yaml) data = yaml.load_file(\"https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml\") set.seed(123) pokemon_list = data$emojis[sample(length(data$emojis), 40)] pokemon_name = sapply(pokemon_list, function(x) x$name) pokemon_src = sapply(pokemon_list, function(x) x$src) library(EBImage) par1 = ccPar(\"points.overflow.warning\" = FALSE) cc = ccPlot(sectors = pokemon_name, xlim = c(0, 1)) track1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2), CELL_META$sector.index, facing = \"clockwise\", niceFacing = TRUE, adj = c(1, 0.5), cex = 0.6) }, bg.border = 1, track.height = 0.15) cc + par1 + track1 Add raster image to the circular plot. Absolute units sectors = letters[1:10] par1 = ccPar(cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0)) cc = ccPlot(sectors = sectors, xlim = cbind(rep(0, 10), runif(10, 0.5, 1.5))) track1 = ccTrack(ylim = c(0, 1), track.height = mm_h(5), panel.fun = function(x, y) { circos.lines(c(0, 0 + mm_x(5)), c(0.5, 0.5), col = \"blue\") }) track2 = ccTrack(ylim = c(0, 1), track.height = cm_h(1), track.margin = c(0, mm_h(2)), panel.fun = function(x, y) { xcenter = get.cell.meta.data(\"xcenter\") circos.lines(c(xcenter, xcenter), c(0, cm_y(1)), col = \"red\") }) track3 = ccTrack(ylim = c(0, 1), track.height = inch_h(1), track.margin = c(0, mm_h(5)), panel.fun = function(x, y) { line_length_on_x = cm_x(1*sqrt(2)/2) line_length_on_y = cm_y(1*sqrt(2)/2) circos.lines(c(0, line_length_on_x), c(0, line_length_on_y), col = \"orange\") }) cc + par1 + track1 + track2 + track3 Setting absolute units","title":"Circular layout"},{"location":"02-circlize-layout/#circular-layout","text":"","title":"Circular layout"},{"location":"02-circlize-layout/#other-utilities","text":"library(yaml) data = yaml.load_file(\"https://raw.githubusercontent.com/Templarian/slack-emoji-pokemon/master/pokemon.yaml\") set.seed(123) pokemon_list = data$emojis[sample(length(data$emojis), 40)] pokemon_name = sapply(pokemon_list, function(x) x$name) pokemon_src = sapply(pokemon_list, function(x) x$src) library(EBImage) par1 = ccPar(\"points.overflow.warning\" = FALSE) cc = ccPlot(sectors = pokemon_name, xlim = c(0, 1)) track1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[1] - mm_y(2), CELL_META$sector.index, facing = \"clockwise\", niceFacing = TRUE, adj = c(1, 0.5), cex = 0.6) }, bg.border = 1, track.height = 0.15) cc + par1 + track1 Add raster image to the circular plot.","title":"Other utilities"},{"location":"02-circlize-layout/#absolute-units","text":"sectors = letters[1:10] par1 = ccPar(cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0)) cc = ccPlot(sectors = sectors, xlim = cbind(rep(0, 10), runif(10, 0.5, 1.5))) track1 = ccTrack(ylim = c(0, 1), track.height = mm_h(5), panel.fun = function(x, y) { circos.lines(c(0, 0 + mm_x(5)), c(0.5, 0.5), col = \"blue\") }) track2 = ccTrack(ylim = c(0, 1), track.height = cm_h(1), track.margin = c(0, mm_h(2)), panel.fun = function(x, y) { xcenter = get.cell.meta.data(\"xcenter\") circos.lines(c(xcenter, xcenter), c(0, cm_y(1)), col = \"red\") }) track3 = ccTrack(ylim = c(0, 1), track.height = inch_h(1), track.margin = c(0, mm_h(5)), panel.fun = function(x, y) { line_length_on_x = cm_x(1*sqrt(2)/2) line_length_on_y = cm_y(1*sqrt(2)/2) circos.lines(c(0, line_length_on_x), c(0, line_length_on_y), col = \"orange\") }) cc + par1 + track1 + track2 + track3 Setting absolute units","title":"Absolute units"},{"location":"03-graphics/","text":"Graphics Segments cc = ccPlot(sectors = letters[1:8], xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), track.height = 0.3, panel.fun = function(x, y) { x = seq(0.2, 0.8, by = 0.2) y = seq(0.2, 0.8, by = 0.2) circos.segments(x, 0.1, x, 0.9) circos.segments(0.1, y, 0.9, y) }) cc + t1 Draw segments. circos.clear() Barplots, boxplots and violin plots par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { value = runif(10) circos.barplot(value, 1:10 - 0.5, col = 1:10) }) t2 = ccTrack(ylim = c(-1, 1), panel.fun = function(x, y) { value = runif(10, min = -1, max = 1) circos.barplot(value, 1:10 - 0.5, col = ifelse(value > 0, 2, 3)) }) cc + t1 + t2 cc = ccPlot(sectors =letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 4), panel.fun = function(x, y) { value = matrix(runif(10*4), ncol = 4) circos.barplot(value, 1:10 - 0.5, col = 2:5) }) cc + t1 Circular barplots. circos.clear() par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { for(pos in seq(0.5, 9.5, by = 1)) { value = runif(10) circos.boxplot(value, pos) } }) cc + t1 cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { value = replicate(runif(10), n = 10, simplify = FALSE) circos.boxplot(value, 1:10 - 0.5, col = 1:10) }) cc + t1 Circular boxplots. circos.clear() par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { for(pos in seq(0.5, 9.5, by = 1)) { value = runif(10) circos.violin(value, pos) } }) cc + t1 cc = ccPlot(sectorsletters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { value = replicate(runif(10), n = 10, simplify = FALSE) circos.violin(value, 1:10 - 0.5, col = 1:10) }) cc + t1 Circular violin plots. circos.clear() Circular arrows par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 1)) col = rand_color(4) tail = c(\"point\", \"normal\", \"point\", \"normal\") t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, arrow.head.width = 0.6, arrow.head.length = cm_x(1), col = col[CELL_META$sector.numeric.index], tail = tail[CELL_META$sector.numeric.index]) }, bg.border = NA, track.height = 0.4) cc + t1 cc = ccPlot(sectors = letters[1:4], xlim = c(0, 1)) tail = c(\"point\", \"normal\", \"point\", \"normal\") t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, arrow.head.width = 0.6, arrow.head.length = cm_x(1), col = col[CELL_META$sector.numeric.index], tail = tail[CELL_META$sector.numeric.index], arrow.position = \"start\") }, bg.border = NA, track.height = 0.4) cc + t1 Circular arrows. cell_cycle = data.frame(phase = factor(c(\"G1\", \"S\", \"G2\", \"M\"), levels = c(\"G1\", \"S\", \"G2\", \"M\")), hour = c(11, 8, 4, 1)) color = c(\"#66C2A5\", \"#FC8D62\", \"#8DA0CB\", \"#E78AC3\") ccp = ccPar(start.degree = 90) cc = ccPlot(sectors = cell_cycle$phase, xlim = cbind(rep(0, 4), cell_cycle$hour)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(CELL_META$xlim[1], CELL_META$xlim[2], arrow.head.width = CELL_META$yrange*0.8, arrow.head.length = cm_x(0.5), col = color[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index, facing = \"downward\") circos.axis(h = 1, major.at = seq(0, round(CELL_META$xlim[2])), minor.ticks = 1, labels.cex = 0.6) }, bg.border = NA, track.height = 0.3) cc + ccp + t1 Cell cycle. circos.clear() Raster image library(png) image = system.file(\"extdata\", \"Rlogo.png\", package = \"circlize\") image = as.raster(readPNG(image)) ccp = ccPar(start.degree = 90) cc = ccPlot(sectors = letters[1:5], xlim = c(0, 1)) all_facing_options = c(\"inside\", \"outside\", \"reverse.clockwise\", \"clockwise\", \"downward\") t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.raster(image, CELL_META$xcenter, CELL_META$ycenter, width = \"1cm\", facing = all_facing_options[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$ycenter, all_facing_options[CELL_META$sector.numeric.index], facing = \"inside\", niceFacing = TRUE) }) cc + ccp + t1 Five facings of raster image. load(system.file(\"extdata\", \"doodle.RData\", package = \"circlize\")) ccp = ccPar(\"cell.padding\" = c(0, 0, 0, 0)) cc = ccPlot(sectors = letters[1:16], xlim = c(0, 1)) t1 =ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { img = img_list[[CELL_META$sector.numeric.index]] circos.raster(img, CELL_META$xcenter, CELL_META$ycenter, width = CELL_META$xrange, height = CELL_META$yrange, facing = \"bending.inside\") }, track.height = 0.25, bg.border = NA) t2 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { img = img_list[[CELL_META$sector.numeric.index + 16]] circos.raster(img, CELL_META$xcenter, CELL_META$ycenter, width = CELL_META$xrange, height = CELL_META$yrange, facing = \"bending.inside\") }, track.height = 0.25, bg.border = NA) cc + ccp + t1 + t2 Fill raster image to the cell. Work together with the base graphic system sectors = letters[1:4] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(1:20/20, 1:20/20) }) cc + t1 text(0, 0, \"This is\\nthe center\", cex = 1.5) legend(\"bottomleft\", pch = 1, legend = \"This is the legend\") title(\"This is the title\") Work with base graphic functions. circos.clear()","title":"Graphics"},{"location":"03-graphics/#graphics","text":"","title":"Graphics"},{"location":"03-graphics/#segments","text":"cc = ccPlot(sectors = letters[1:8], xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), track.height = 0.3, panel.fun = function(x, y) { x = seq(0.2, 0.8, by = 0.2) y = seq(0.2, 0.8, by = 0.2) circos.segments(x, 0.1, x, 0.9) circos.segments(0.1, y, 0.9, y) }) cc + t1 Draw segments. circos.clear()","title":"Segments"},{"location":"03-graphics/#barplots-boxplots-and-violin-plots","text":"par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { value = runif(10) circos.barplot(value, 1:10 - 0.5, col = 1:10) }) t2 = ccTrack(ylim = c(-1, 1), panel.fun = function(x, y) { value = runif(10, min = -1, max = 1) circos.barplot(value, 1:10 - 0.5, col = ifelse(value > 0, 2, 3)) }) cc + t1 + t2 cc = ccPlot(sectors =letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 4), panel.fun = function(x, y) { value = matrix(runif(10*4), ncol = 4) circos.barplot(value, 1:10 - 0.5, col = 2:5) }) cc + t1 Circular barplots. circos.clear() par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { for(pos in seq(0.5, 9.5, by = 1)) { value = runif(10) circos.boxplot(value, pos) } }) cc + t1 cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { value = replicate(runif(10), n = 10, simplify = FALSE) circos.boxplot(value, 1:10 - 0.5, col = 1:10) }) cc + t1 Circular boxplots. circos.clear() par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { for(pos in seq(0.5, 9.5, by = 1)) { value = runif(10) circos.violin(value, pos) } }) cc + t1 cc = ccPlot(sectorsletters[1:4], xlim = c(0, 10)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { value = replicate(runif(10), n = 10, simplify = FALSE) circos.violin(value, 1:10 - 0.5, col = 1:10) }) cc + t1 Circular violin plots. circos.clear()","title":"Barplots, boxplots and violin plots"},{"location":"03-graphics/#circular-arrows","text":"par(mfrow = c(1, 2)) cc = ccPlot(sectors = letters[1:4], xlim = c(0, 1)) col = rand_color(4) tail = c(\"point\", \"normal\", \"point\", \"normal\") t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, arrow.head.width = 0.6, arrow.head.length = cm_x(1), col = col[CELL_META$sector.numeric.index], tail = tail[CELL_META$sector.numeric.index]) }, bg.border = NA, track.height = 0.4) cc + t1 cc = ccPlot(sectors = letters[1:4], xlim = c(0, 1)) tail = c(\"point\", \"normal\", \"point\", \"normal\") t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(x1 = 0, x2 = 1, y = 0.5, width = 0.4, arrow.head.width = 0.6, arrow.head.length = cm_x(1), col = col[CELL_META$sector.numeric.index], tail = tail[CELL_META$sector.numeric.index], arrow.position = \"start\") }, bg.border = NA, track.height = 0.4) cc + t1 Circular arrows. cell_cycle = data.frame(phase = factor(c(\"G1\", \"S\", \"G2\", \"M\"), levels = c(\"G1\", \"S\", \"G2\", \"M\")), hour = c(11, 8, 4, 1)) color = c(\"#66C2A5\", \"#FC8D62\", \"#8DA0CB\", \"#E78AC3\") ccp = ccPar(start.degree = 90) cc = ccPlot(sectors = cell_cycle$phase, xlim = cbind(rep(0, 4), cell_cycle$hour)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.arrow(CELL_META$xlim[1], CELL_META$xlim[2], arrow.head.width = CELL_META$yrange*0.8, arrow.head.length = cm_x(0.5), col = color[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$ycenter, CELL_META$sector.index, facing = \"downward\") circos.axis(h = 1, major.at = seq(0, round(CELL_META$xlim[2])), minor.ticks = 1, labels.cex = 0.6) }, bg.border = NA, track.height = 0.3) cc + ccp + t1 Cell cycle. circos.clear()","title":"Circular arrows"},{"location":"03-graphics/#raster-image","text":"library(png) image = system.file(\"extdata\", \"Rlogo.png\", package = \"circlize\") image = as.raster(readPNG(image)) ccp = ccPar(start.degree = 90) cc = ccPlot(sectors = letters[1:5], xlim = c(0, 1)) all_facing_options = c(\"inside\", \"outside\", \"reverse.clockwise\", \"clockwise\", \"downward\") t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.raster(image, CELL_META$xcenter, CELL_META$ycenter, width = \"1cm\", facing = all_facing_options[CELL_META$sector.numeric.index]) circos.text(CELL_META$xcenter, CELL_META$ycenter, all_facing_options[CELL_META$sector.numeric.index], facing = \"inside\", niceFacing = TRUE) }) cc + ccp + t1 Five facings of raster image. load(system.file(\"extdata\", \"doodle.RData\", package = \"circlize\")) ccp = ccPar(\"cell.padding\" = c(0, 0, 0, 0)) cc = ccPlot(sectors = letters[1:16], xlim = c(0, 1)) t1 =ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { img = img_list[[CELL_META$sector.numeric.index]] circos.raster(img, CELL_META$xcenter, CELL_META$ycenter, width = CELL_META$xrange, height = CELL_META$yrange, facing = \"bending.inside\") }, track.height = 0.25, bg.border = NA) t2 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { img = img_list[[CELL_META$sector.numeric.index + 16]] circos.raster(img, CELL_META$xcenter, CELL_META$ycenter, width = CELL_META$xrange, height = CELL_META$yrange, facing = \"bending.inside\") }, track.height = 0.25, bg.border = NA) cc + ccp + t1 + t2 Fill raster image to the cell.","title":"Raster image"},{"location":"03-graphics/#work-together-with-the-base-graphic-system","text":"sectors = letters[1:4] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(1:20/20, 1:20/20) }) cc + t1 text(0, 0, \"This is\\nthe center\", cex = 1.5) legend(\"bottomleft\", pch = 1, legend = \"This is the legend\") title(\"This is the title\") Work with base graphic functions. circos.clear()","title":"Work together with the base graphic system"},{"location":"04-legends/","text":"Legends col_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"yellow\", \"red\")) circlize_plot = function() { set.seed(12345) sectors = letters[1:10] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 2) circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 3) }) t2 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.lines(sort(runif(20)), runif(20), col = 4) circos.lines(sort(runif(20)), runif(20), col = 5) }) cc = cc + t1 + t2 for(i in 1:10) { l = ccLink(sample(sectors, 1), sort(runif(10))[1:2], sample(sectors, 1), sort(runif(10))[1:2], col = add_transparency(col_fun(rnorm(1)))) cc = cc + l } cc } library(ComplexHeatmap) # discrete lgd_points = Legend(at = c(\"label1\", \"label2\"), type = \"points\", legend_gp = gpar(col = 2:3), title_position = \"topleft\", title = \"Track1\") # discrete lgd_lines = Legend(at = c(\"label3\", \"label4\"), type = \"lines\", legend_gp = gpar(col = 4:5, lwd = 2), title_position = \"topleft\", title = \"Track2\") # continuous lgd_links = Legend(at = c(-2, -1, 0, 1, 2), col_fun = col_fun, title_position = \"topleft\", title = \"Links\") lgd_list_vertical = packLegend(lgd_points, lgd_lines, lgd_links) lgd_list_vertical circlize_plot() # next the grid graphics are added directly to the plot # where circlize has created. draw(lgd_list_vertical, x = unit(4, \"mm\"), y = unit(4, \"mm\"), just = c(\"left\", \"bottom\")) Directly add grid graphics. lgd_list_vertical2 = packLegend(lgd_points, lgd_lines) circlize_plot() # next the grid graphics are added directly to the plot # where circlize has created. draw(lgd_list_vertical2, x = unit(4, \"mm\"), y = unit(4, \"mm\"), just = c(\"left\", \"bottom\")) draw(lgd_links, x = unit(1, \"npc\") - unit(2, \"mm\"), y = unit(4, \"mm\"), just = c(\"right\", \"bottom\")) Split into two legends. library(gridBase) plot.new() circle_size = unit(1, \"snpc\") # snpc unit gives you a square region pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size, just = c(\"left\", \"center\"))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() draw(lgd_list_vertical, x = circle_size, just = \"left\") lgd_points = Legend(at = c(\"label1\", \"label2\"), type = \"points\", legend_gp = gpar(col = 2:3), title_position = \"topleft\", title = \"Track1\", nrow = 1) lgd_lines = Legend(at = c(\"label3\", \"label4\"), type = \"lines\", legend_gp = gpar(col = 4:5, lwd = 2), title_position = \"topleft\", title = \"Track2\", nrow = 1) lgd_links = Legend(at = c(-2, -1, 0, 1, 2), col_fun = col_fun, title_position = \"topleft\", title = \"Links\", direction = \"horizontal\") lgd_list_horizontal = packLegend(lgd_points, lgd_lines, lgd_links, direction = \"horizontal\") Similar code to arrange viewports. plot.new() pushViewport(viewport(x = 0.5, y = 1, width = circle_size, height = circle_size, just = c(\"center\", \"top\"))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() draw(lgd_list_horizontal, y = unit(1, \"npc\") - circle_size, just = \"bottom\")","title":"Legends"},{"location":"04-legends/#legends","text":"col_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"yellow\", \"red\")) circlize_plot = function() { set.seed(12345) sectors = letters[1:10] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 2) circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 3) }) t2 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.lines(sort(runif(20)), runif(20), col = 4) circos.lines(sort(runif(20)), runif(20), col = 5) }) cc = cc + t1 + t2 for(i in 1:10) { l = ccLink(sample(sectors, 1), sort(runif(10))[1:2], sample(sectors, 1), sort(runif(10))[1:2], col = add_transparency(col_fun(rnorm(1)))) cc = cc + l } cc } library(ComplexHeatmap) # discrete lgd_points = Legend(at = c(\"label1\", \"label2\"), type = \"points\", legend_gp = gpar(col = 2:3), title_position = \"topleft\", title = \"Track1\") # discrete lgd_lines = Legend(at = c(\"label3\", \"label4\"), type = \"lines\", legend_gp = gpar(col = 4:5, lwd = 2), title_position = \"topleft\", title = \"Track2\") # continuous lgd_links = Legend(at = c(-2, -1, 0, 1, 2), col_fun = col_fun, title_position = \"topleft\", title = \"Links\") lgd_list_vertical = packLegend(lgd_points, lgd_lines, lgd_links) lgd_list_vertical circlize_plot() # next the grid graphics are added directly to the plot # where circlize has created. draw(lgd_list_vertical, x = unit(4, \"mm\"), y = unit(4, \"mm\"), just = c(\"left\", \"bottom\")) Directly add grid graphics. lgd_list_vertical2 = packLegend(lgd_points, lgd_lines) circlize_plot() # next the grid graphics are added directly to the plot # where circlize has created. draw(lgd_list_vertical2, x = unit(4, \"mm\"), y = unit(4, \"mm\"), just = c(\"left\", \"bottom\")) draw(lgd_links, x = unit(1, \"npc\") - unit(2, \"mm\"), y = unit(4, \"mm\"), just = c(\"right\", \"bottom\")) Split into two legends. library(gridBase) plot.new() circle_size = unit(1, \"snpc\") # snpc unit gives you a square region pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size, just = c(\"left\", \"center\"))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() draw(lgd_list_vertical, x = circle_size, just = \"left\") lgd_points = Legend(at = c(\"label1\", \"label2\"), type = \"points\", legend_gp = gpar(col = 2:3), title_position = \"topleft\", title = \"Track1\", nrow = 1) lgd_lines = Legend(at = c(\"label3\", \"label4\"), type = \"lines\", legend_gp = gpar(col = 4:5, lwd = 2), title_position = \"topleft\", title = \"Track2\", nrow = 1) lgd_links = Legend(at = c(-2, -1, 0, 1, 2), col_fun = col_fun, title_position = \"topleft\", title = \"Links\", direction = \"horizontal\") lgd_list_horizontal = packLegend(lgd_points, lgd_lines, lgd_links, direction = \"horizontal\") Similar code to arrange viewports. plot.new() pushViewport(viewport(x = 0.5, y = 1, width = circle_size, height = circle_size, just = c(\"center\", \"top\"))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() draw(lgd_list_horizontal, y = unit(1, \"npc\") - circle_size, just = \"bottom\")","title":"Legends"},{"location":"05-implement-high-level-plots/","text":"Implement high-level circular plots Circular barplots category = paste0(\"category\", \"_\", 1:9) percent = sort(sample(40:80, 9)) color = rev(rainbow(length(percent))) par1 = ccPar(\"start.degree\" = 90, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = \"a\", xlim = c(0, 100)) # 'a` just means there is one sector t1 = ccTrack(ylim = c(0.5, length(percent)+0.5), track.height = 0.8, bg.border = NA, panel.fun = function(x, y) { xlim = CELL_META$xlim circos.segments(rep(xlim[1], 9), 1:9, rep(xlim[2], 9), 1:9, col = \"#CCCCCC\") circos.rect(rep(0, 9), 1:9 - 0.45, percent, 1:9 + 0.45, col = color, border = \"white\") circos.text(rep(xlim[1], 9), 1:9, paste(category, \" - \", percent, \"%\"), facing = \"downward\", adj = c(1.05, 0.5), cex = 0.8) breaks = seq(0, 85, by = 5) circos.axis(h = \"top\", major.at = breaks, labels = paste0(breaks, \"%\"), labels.cex = 0.6) }) cc + par1 + t1 A circular barplot. circos.clear() circos.text(xlim[1] - mm_x(2, h = 1:9), 1:9, paste(category, \" - \", percent, \"%\"), facing = \"downward\", adj = c(1, 0.5), cex = 0.8) Histograms x = rnorm(1600) sectors = sample(letters[1:16], 1600, replace = TRUE) cc = ccPlot(sectors = sectors, x = x) t1 = ccTrackHist(sectors, x = x, col = \"#999999\", border = \"#999999\") t2 = ccTrackHist(sectors, x = x, bin.size = 0.1, col = \"#999999\", border = \"#999999\") t3 = ccTrackHist(sectors, x = x, draw.density = TRUE, col = \"#999999\", border = \"#999999\") cc + t1 + t2 + t3 Histograms on circular layout. circos.clear() Phylogenetic trees library(ape) data(bird.orders) hc = as.hclust(bird.orders) labels = hc$labels # name of birds ct = cutree(hc, 6) # cut tree into 6 pieces n = length(labels) # number of bird species dend = as.dendrogram(hc) par1 = ccPar(cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = \"a\", xlim = c(0, n)) # only one sector t1 = ccTrack(ylim = c(0, 1), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) { for(i in seq_len(n)) { circos.text(i-0.5, 0, labels[i], adj = c(0, 0.5), facing = \"clockwise\", niceFacing = TRUE, col = ct[labels[i]], cex = 0.5) } }) suppressPackageStartupMessages(library(dendextend)) dend = color_branches(dend, k = 6, col = 1:6) dend_height = attr(dend, \"height\") t2 = ccTrack(ylim = c(0, dend_height), bg.border = NA, track.height = 0.4, panel.fun = function(x, y) { circos.dendrogram(dend) }) cc + par1 + t1 + t2 circos.dendrogram(dend, facing = \"inside\") (\\#fig:phylogenetic-tree)A circular phylogenetic tree. Manually create heatmaps mat = matrix(rnorm(100*10), nrow = 100, ncol = 10) col_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"black\", \"red\")) sectors = rep(letters[1:2], times = c(30, 70)) mat_list = list(a = mat[sectors == \"a\", ], b = mat[sectors == \"b\", ]) dend_list = list(a = as.dendrogram(hclust(dist(mat_list[[\"a\"]]))), b = as.dendrogram(hclust(dist(mat_list[[\"b\"]])))) par1 = ccPar(cell.padding = c(0, 0, 0, 0), gap.degree = 5) cc = ccPlot(sectors = sectors, xlim = cbind(c(0, 0), table(sectors))) t1 = ccTrack(ylim = c(0, 10), bg.border = NA, panel.fun = function(x, y) { sector.index = CELL_META$sector.index m = mat_list[[sector.index]] dend = dend_list[[sector.index]] m2 = m[order.dendrogram(dend), ] col_mat = col_fun(m2) nr = nrow(m2) nc = ncol(m2) for(i in 1:nc) { circos.rect(1:nr - 1, rep(nc - i, nr), 1:nr, rep(nc - i + 1, nr), border = col_mat[, i], col = col_mat[, i]) } }) max_height = max(sapply(dend_list, function(x) attr(x, \"height\"))) t2 = ccTrack(ylim = c(0, max_height), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) { sector.index = get.cell.meta.data(\"sector.index\") dend = dend_list[[sector.index]] circos.dendrogram(dend, max_height = max_height) }) cc + par1 + t1 + t2 circos.clear() Circular heatmaps.","title":"Implement high-level circular plots"},{"location":"05-implement-high-level-plots/#implement-high-level-circular-plots","text":"","title":"Implement high-level circular plots"},{"location":"05-implement-high-level-plots/#circular-barplots","text":"category = paste0(\"category\", \"_\", 1:9) percent = sort(sample(40:80, 9)) color = rev(rainbow(length(percent))) par1 = ccPar(\"start.degree\" = 90, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = \"a\", xlim = c(0, 100)) # 'a` just means there is one sector t1 = ccTrack(ylim = c(0.5, length(percent)+0.5), track.height = 0.8, bg.border = NA, panel.fun = function(x, y) { xlim = CELL_META$xlim circos.segments(rep(xlim[1], 9), 1:9, rep(xlim[2], 9), 1:9, col = \"#CCCCCC\") circos.rect(rep(0, 9), 1:9 - 0.45, percent, 1:9 + 0.45, col = color, border = \"white\") circos.text(rep(xlim[1], 9), 1:9, paste(category, \" - \", percent, \"%\"), facing = \"downward\", adj = c(1.05, 0.5), cex = 0.8) breaks = seq(0, 85, by = 5) circos.axis(h = \"top\", major.at = breaks, labels = paste0(breaks, \"%\"), labels.cex = 0.6) }) cc + par1 + t1 A circular barplot. circos.clear() circos.text(xlim[1] - mm_x(2, h = 1:9), 1:9, paste(category, \" - \", percent, \"%\"), facing = \"downward\", adj = c(1, 0.5), cex = 0.8)","title":"Circular barplots"},{"location":"05-implement-high-level-plots/#histograms","text":"x = rnorm(1600) sectors = sample(letters[1:16], 1600, replace = TRUE) cc = ccPlot(sectors = sectors, x = x) t1 = ccTrackHist(sectors, x = x, col = \"#999999\", border = \"#999999\") t2 = ccTrackHist(sectors, x = x, bin.size = 0.1, col = \"#999999\", border = \"#999999\") t3 = ccTrackHist(sectors, x = x, draw.density = TRUE, col = \"#999999\", border = \"#999999\") cc + t1 + t2 + t3 Histograms on circular layout. circos.clear()","title":"Histograms"},{"location":"05-implement-high-level-plots/#phylogenetic-trees","text":"library(ape) data(bird.orders) hc = as.hclust(bird.orders) labels = hc$labels # name of birds ct = cutree(hc, 6) # cut tree into 6 pieces n = length(labels) # number of bird species dend = as.dendrogram(hc) par1 = ccPar(cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = \"a\", xlim = c(0, n)) # only one sector t1 = ccTrack(ylim = c(0, 1), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) { for(i in seq_len(n)) { circos.text(i-0.5, 0, labels[i], adj = c(0, 0.5), facing = \"clockwise\", niceFacing = TRUE, col = ct[labels[i]], cex = 0.5) } }) suppressPackageStartupMessages(library(dendextend)) dend = color_branches(dend, k = 6, col = 1:6) dend_height = attr(dend, \"height\") t2 = ccTrack(ylim = c(0, dend_height), bg.border = NA, track.height = 0.4, panel.fun = function(x, y) { circos.dendrogram(dend) }) cc + par1 + t1 + t2 circos.dendrogram(dend, facing = \"inside\") (\\#fig:phylogenetic-tree)A circular phylogenetic tree.","title":"Phylogenetic trees"},{"location":"05-implement-high-level-plots/#manually-create-heatmaps","text":"mat = matrix(rnorm(100*10), nrow = 100, ncol = 10) col_fun = colorRamp2(c(-2, 0, 2), c(\"green\", \"black\", \"red\")) sectors = rep(letters[1:2], times = c(30, 70)) mat_list = list(a = mat[sectors == \"a\", ], b = mat[sectors == \"b\", ]) dend_list = list(a = as.dendrogram(hclust(dist(mat_list[[\"a\"]]))), b = as.dendrogram(hclust(dist(mat_list[[\"b\"]])))) par1 = ccPar(cell.padding = c(0, 0, 0, 0), gap.degree = 5) cc = ccPlot(sectors = sectors, xlim = cbind(c(0, 0), table(sectors))) t1 = ccTrack(ylim = c(0, 10), bg.border = NA, panel.fun = function(x, y) { sector.index = CELL_META$sector.index m = mat_list[[sector.index]] dend = dend_list[[sector.index]] m2 = m[order.dendrogram(dend), ] col_mat = col_fun(m2) nr = nrow(m2) nc = ncol(m2) for(i in 1:nc) { circos.rect(1:nr - 1, rep(nc - i, nr), 1:nr, rep(nc - i + 1, nr), border = col_mat[, i], col = col_mat[, i]) } }) max_height = max(sapply(dend_list, function(x) attr(x, \"height\"))) t2 = ccTrack(ylim = c(0, max_height), bg.border = NA, track.height = 0.3, panel.fun = function(x, y) { sector.index = get.cell.meta.data(\"sector.index\") dend = dend_list[[sector.index]] circos.dendrogram(dend, max_height = max_height) }) cc + par1 + t1 + t2 circos.clear() Circular heatmaps.","title":"Manually create heatmaps"},{"location":"06-circos-heatmap/","text":"The circos.heatmap() function set.seed(123) mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), matrix(rnorm(50*5, mean = -1), nr = 50)), cbind(matrix(rnorm(50*5, mean = -1), nr = 50), matrix(rnorm(50*5, mean = 1), nr = 50)) ) rownames(mat1) = paste0(\"R\", 1:100) colnames(mat1) = paste0(\"C\", 1:10) mat1 = mat1[sample(100, 100), ] # randomly permute rows split = sample(letters[1:5], 100, replace = TRUE) split = factor(split, levels = letters[1:5]) library(ComplexHeatmap) Heatmap(mat1, row_split = split) A normal heatmap. Input data library(circlize) # >= 0.4.10 col_fun1 = colorRamp2(c(-2, 0, 2), c(\"blue\", \"white\", \"red\")) ccHeatmap(mat = mat1, split = split, col = col_fun1) A circular heatmap which has been split. circos.clear() ccHeatmap(mat = mat1, col = col_fun1) A circular heatmap which no split. circos.clear() Circular layout par1 = ccPar(start.degree = 90, gap.degree = 10) cc = ccHeatmap(mat = mat1, split = split, col = col_fun1, track.height = 0.4, bg.border = \"green\", bg.lwd = 2, bg.lty = 2, show.sector.labels = TRUE) cc + par1 Circular heatmap. Control the layout. circos.clear() # note since circos.clear() was called in the previous plot, # now the layout starts from theta = 0 (the first sector is 'e') ccHeatmap(mat = mat1, split = factor(split, levels = c(\"e\", \"d\", \"c\", \"b\", \"a\")), col = col_fun1, show.sector.labels = TRUE) Circular heatmap. Control the order of heatmaps. circos.clear() Dendrograms and row names ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\") circos.clear() ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"outside\") circos.clear() Circular heatmap. Control the dendrograms. ccHeatmap(mat = mat1, split = split, col = col_fun1, rownames.side = \"inside\") circos.clear() text(0, 0, 'rownames.side = \"inside\"') ccHeatmap(mat = mat1, split = split, col = col_fun1, rownames.side = \"outside\") circos.clear() text(0, 0, 'rownames.side = \"outside\"') Circular heatmap. Control the row names. ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\", rownames.side = \"outside\") circos.clear() ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"outside\", rownames.side = \"inside\") circos.clear() Circular heatmap. Control both the dendrograms and row names. ccHeatmap(mat = mat1, split = split, col = col_fun1, rownames.side = \"outside\", rownames.col = 1:nrow(mat1) %% 10 + 1, rownames.cex = runif(nrow(mat1), min = 0.3, max = 2), rownames.font = 1:nrow(mat1) %% 4 + 1) Circular heatmap. Control graphic parameters for row names. circos.clear() Clustering ccHeatmap(mat = mat1, split = split, cluster = FALSE, col = col_fun1) circos.clear() Circular heatmap. Control clusterings. Callback on dendrograms function(dend, m, si) reorder(dend, rowMeans(m)) library(dendsort) ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\", dend.callback = function(dend, m, si) { dendsort(dend) } ) circos.clear() Circular Heatmap. Reorder dendrograms. library(dendextend) dend_col = structure(1:5, names = letters[1:5]) ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\", dend.track.height = 0.2, dend.callback = function(dend, m, si) { # when k = 1, it renders one same color for the whole dendrogram color_branches(dend, k = 1, col = dend_col[si]) } ) Circular heatmap. Render dendrograms that were split. circos.clear() ccHeatmap(mat = mat1, col = col_fun1, dend.side = \"inside\", dend.track.height = 0.2, dend.callback = function(dend, m, si) { color_branches(dend, k = 4, col = 2:5) } ) Circular heatmap. Render dendrograms. circos.clear() Multiple heatmap tracks mat2 = mat1[sample(100, 100), ] # randomly permute mat1 by rows col_fun2 = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")) hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"outside\") hm2 = ccHeatmap(mat = mat2, col = col_fun2) hm1 + hm2 circos.clear() hm1 = ccHeatmap(mat = mat2, split = split, col = col_fun2, dend.side = \"outside\") hm2 = ccHatmap(mat = mat1, col = col_fun1) hm1 + hm2 circos.clear() cc = ccPlot(initFunc='heatmap.initialize', mat = mat1, split = split) hm1 = ccHeatmap(mat = mat2, col = col_fun2, dend.side = \"outside\") hm2 = ccHeatmap(mat = mat1, col = col_fun1) cc + hm1 + hm2 circos.clear() cc = ccPlot(initFunc='heatmap.initialize', mat = mat1, split = split) hm1 = ccHeatmap(mat = mat1[, 1:5], col = col_fun1) hm2 = ccHeatmap(mat = mat1[, 6:10], col = col_fun1) cc + hm1 + hm2 circos.clear() With other tracks CELL_META$row_dend ## 'dendrogram' with 2 branches and 14 members total, at height 10.51736 CELL_META$row_order ## [1] 2 6 4 12 8 1 5 10 7 9 13 11 3 14 CELL_META$subset ## [1] 8 9 14 18 20 37 55 62 66 72 78 85 93 97 hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) row_mean = rowMeans(mat1[, 1:5]) t1 = ccTrack(ylim = range(row_mean), panel.fun = function(x, y) { y = row_mean[CELL_META$subset] y = y[CELL_META$row_order] circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"grey\") circos.points(seq_along(y) - 0.5, y, col = ifelse(y > 0, \"red\", \"blue\")) }, cell.padding = c(0.02, 0, 0.02, 0)) hm1 + t1 circos.clear() cc = ccPlot(initFunc='heatmap.initialize', mat = mat1, split = split) # This is the same as the previous example t1 = ccTrack(ylim = range(row_mean), panel.fun = function(x, y) { y = row_mean[CELL_META$subset] y = y[CELL_META$row_order] circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"grey\") circos.points(seq_along(y) - 0.5, y, col = ifelse(y > 0, \"red\", \"blue\")) }, cell.padding = c(0.02, 0, 0.02, 0)) hm1 = ccHeatmap(mat1, col = col_fun1) # no need to specify 'split' here cc + t1 + hm1 circos.clear() hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) t1 = ccTrack(ylim = range(mat1), panel.fun = function(x, y) { m = mat1[CELL_META$subset, 1:5, drop = FALSE] m = m[CELL_META$row_order, , drop = FALSE] n = nrow(m) # circos.boxplot is applied on matrix columns, so here we transpose it. circos.boxplot(t(m), pos = 1:n - 0.5, pch = 16, cex = 0.3) circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"grey\") }, cell.padding = c(0.02, 0, 0.02, 0)) hm1 + t1 circos.clear() Add annotations hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) hm1 circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + convert_y(2, \"mm\"), paste0(\"this is group \", CELL_META$sector.index), facing = \"bending.inside\", cex = 0.8, adj = c(0.5, 0), niceFacing = TRUE) }, bg.border = NA) circos.clear() par1 = ccPar(gap.after = c(2, 2, 2, 2, 10)) hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1, track.height = 0.4) hm1 + par1 circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { if(CELL_META$sector.numeric.index == 5) { # the last sector cn = colnames(mat1) n = length(cn) circos.text(rep(CELL_META$cell.xlim[2], n) + convert_x(1, \"mm\"), 1:n - 0.5, cn, cex = 0.5, adj = c(0, 0.5), facing = \"inside\") } }, bg.border = NA) circos.clear() par1 = ccPar(gap.after = c(2, 2, 2, 2, 10)) hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1, track.height = 0.4) hm1 + par1 circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { if(CELL_META$sector.numeric.index == 5) { # the last sector circos.rect(CELL_META$cell.xlim[2] + convert_x(1, \"mm\"), 0, CELL_META$cell.xlim[2] + convert_x(5, \"mm\"), 5, col = \"orange\", border = NA) circos.text(CELL_META$cell.xlim[2] + convert_x(3, \"mm\"), 2.5, \"group 1\", cex = 0.5, facing = \"clockwise\") circos.rect(CELL_META$cell.xlim[2] + convert_x(1, \"mm\"), 5, CELL_META$cell.xlim[2] + convert_x(5, \"mm\"), 10, col = \"pink\", border = NA) circos.text(CELL_META$cell.xlim[2] + convert_x(3, \"mm\"), 7.5, \"group 2\", cex = 0.5, facing = \"clockwise\") } }, bg.border = NA) circos.clear() hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) hm1 circos.clear() library(ComplexHeatmap) lgd = Legend(title = \"mat1\", col_fun = col_fun1) grid.draw(lgd) A complex example of circular heatmaps source(\"https://gist.githubusercontent.com/jokergoo/0ea5639ee25a7edae3871ed8252924a1/raw/57ca9426c2ed0cebcffd79db27a024033e5b8d52/random_matrices.R\") set.seed(123) km = kmeans(mat_meth, centers = 5)$cluster col_meth = colorRamp2(c(0, 0.5, 1), c(\"blue\", \"white\", \"red\")) hm1 = ccHeatmap(mat = mat_meth, split = km, col = col_meth, track.height = 0.12) col_direction = c(\"hyper\" = \"red\", \"hypo\" = \"blue\") hm2 = ccHeatmap(mat = direction, col = col_direction, track.height = 0.01) col_expr = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")) hm3 = ccHeatmap(mat = mat_expr, col = col_expr, track.height = 0.12) col_pvalue = colorRamp2(c(0, 2, 4), c(\"white\", \"white\", \"red\")) hm4 = ccHeatmap(mat = cor_pvalue, col = col_pvalue, track.height = 0.01) library(RColorBrewer) col_gene_type = structure(brewer.pal(length(unique(gene_type)), \"Set3\"), names = unique(gene_type)) hm5 = ccHeatmap(mat = gene_type, col = col_gene_type, track.height = 0.01) col_anno_gene = structure(brewer.pal(length(unique(anno_gene)), \"Set1\"), names = unique(anno_gene)) hm6 = ccHeatmap(mat = anno_gene, col = col_anno_gene, track.height = 0.01) col_dist = colorRamp2(c(0, 10000), c(\"black\", \"white\")) hm7 = ccHeatmap(mat = dist, col = col_dist, track.height = 0.01) col_enhancer = colorRamp2(c(0, 1), c(\"white\", \"orange\")) hm8 = ccHeatmap(mat = anno_enhancer, col = col_enhancer, track.height = 0.03) cc = hm1 + hm2 + hm3 + hm4 + hm5 + hm6 + hm7 + hm8 cc circos.clear() df_link = data.frame( from_index = sample(nrow(mat_meth), 20), to_index = sample(nrow(mat_meth), 20) ) for(i in seq_len(nrow(df_link))) { # Let's call the DMR with index df_link$from_index[i] as DMR1, # and the other one with index df_link$to_index[i] as DMR2. # The sector where DMR1 is in. group1 = km[ df_link$from_index[i] ] # The sector where DMR2 is in. group2 = km[ df_link$to_index[i] ] # The subset of DMRs (row indices from mat_meth) in sector `group1`. subset1 = get.cell.meta.data(\"subset\", sector.index = group1) # The row ordering in sector `group1`. row_order1 = get.cell.meta.data(\"row_order\", sector.index = group1) # This is the position of DMR1 in the `group1` heatmap. x1 = which(subset1[row_order1] == df_link$from_index[i]) # The subset of DMRs (row indices from mat_meth) in sector `group2`. subset2 = get.cell.meta.data(\"subset\", sector.index = group2) # The row ordering in sector `group2`. row_order2 = get.cell.meta.data(\"row_order\", sector.index = group2) # This is the position of DMR2 in the `group2` heatmap. x2 = which(subset2[row_order2] == df_link$to_index[i]) # We take the middle point and draw a link between DMR1 and DMR2 cc = cc + ccLink(group1, x1 - 0.5, group2, x2 - 0.5, col = rand_color(1)) } cc for(i in seq_len(nrow(df_link))) { cc = cc + ccHeatmapLink(df_link$from_index[i], df_link$to_index[i], col = rand_color(1)) } cc circlize_plot = function() { hm1 = ccHeatmap(mat = mat_meth, split = km, col = col_meth, track.height = 0.12) hm2 = ccHeatmap(mat = direction, col = col_direction, track.height = 0.01) hm3 = ccHeatmap(mat = mat_expr, col = col_expr, track.height = 0.12) hm4 = ccHeatmap(mat = cor_pvalue, col = col_pvalue, track.height = 0.01) hm5 = ccHeatmap(mat = gene_type, col = col_gene_type, track.height = 0.01) hm6 = ccHeatmap(mat = anno_gene, col = col_anno_gene, track.height = 0.01) hm7 = ccHeatmap(mat = dist, col = col_dist, track.height = 0.01) hm8 = ccHeatmap(mat = anno_enhancer, col = col_enhancer, track.height = 0.03) cc = hm1 + hm2 + hm3 + hm4 + hm5 + hm6 + hm7 + hm8 for(i in seq_len(nrow(df_link))) { cc = cc + ccHeatmapLink(df_link$from_index[i], df_link$to_index[i], col = rand_color(1)) } show(cc) circos.clear() } lgd_meth = Legend(title = \"Methylation\", col_fun = col_meth) lgd_direction = Legend(title = \"Direction\", at = names(col_direction), legend_gp = gpar(fill = col_direction)) lgd_expr = Legend(title = \"Expression\", col_fun = col_expr) lgd_pvalue = Legend(title = \"P-value\", col_fun = col_pvalue, at = c(0, 2, 4), labels = c(1, 0.01, 0.0001)) lgd_gene_type = Legend(title = \"Gene type\", at = names(col_gene_type), legend_gp = gpar(fill = col_gene_type)) lgd_anno_gene = Legend(title = \"Gene anno\", at = names(col_anno_gene), legend_gp = gpar(fill = col_anno_gene)) lgd_dist = Legend(title = \"Dist to TSS\", col_fun = col_dist, at = c(0, 5000, 10000), labels = c(\"0kb\", \"5kb\", \"10kb\")) lgd_enhancer = Legend(title = \"Enhancer overlap\", col_fun = col_enhancer, at = c(0, 0.25, 0.5, 0.75, 1), labels = c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\")) library(gridBase) plot.new() circle_size = unit(1, \"snpc\") # snpc unit gives you a square region pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size, just = c(\"left\", \"center\"))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() h = dev.size()[2] lgd_list = packLegend(lgd_meth, lgd_direction, lgd_expr, lgd_pvalue, lgd_gene_type, lgd_anno_gene, lgd_dist, lgd_enhancer, max_height = unit(0.9*h, \"inch\")) draw(lgd_list, x = circle_size, just = \"left\")","title":"The circos.heatmap() function"},{"location":"06-circos-heatmap/#the-circosheatmap-function","text":"set.seed(123) mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), matrix(rnorm(50*5, mean = -1), nr = 50)), cbind(matrix(rnorm(50*5, mean = -1), nr = 50), matrix(rnorm(50*5, mean = 1), nr = 50)) ) rownames(mat1) = paste0(\"R\", 1:100) colnames(mat1) = paste0(\"C\", 1:10) mat1 = mat1[sample(100, 100), ] # randomly permute rows split = sample(letters[1:5], 100, replace = TRUE) split = factor(split, levels = letters[1:5]) library(ComplexHeatmap) Heatmap(mat1, row_split = split) A normal heatmap.","title":"The circos.heatmap() function"},{"location":"06-circos-heatmap/#input-data","text":"library(circlize) # >= 0.4.10 col_fun1 = colorRamp2(c(-2, 0, 2), c(\"blue\", \"white\", \"red\")) ccHeatmap(mat = mat1, split = split, col = col_fun1) A circular heatmap which has been split. circos.clear() ccHeatmap(mat = mat1, col = col_fun1) A circular heatmap which no split. circos.clear()","title":"Input data"},{"location":"06-circos-heatmap/#circular-layout","text":"par1 = ccPar(start.degree = 90, gap.degree = 10) cc = ccHeatmap(mat = mat1, split = split, col = col_fun1, track.height = 0.4, bg.border = \"green\", bg.lwd = 2, bg.lty = 2, show.sector.labels = TRUE) cc + par1 Circular heatmap. Control the layout. circos.clear() # note since circos.clear() was called in the previous plot, # now the layout starts from theta = 0 (the first sector is 'e') ccHeatmap(mat = mat1, split = factor(split, levels = c(\"e\", \"d\", \"c\", \"b\", \"a\")), col = col_fun1, show.sector.labels = TRUE) Circular heatmap. Control the order of heatmaps. circos.clear()","title":"Circular layout"},{"location":"06-circos-heatmap/#dendrograms-and-row-names","text":"ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\") circos.clear() ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"outside\") circos.clear() Circular heatmap. Control the dendrograms. ccHeatmap(mat = mat1, split = split, col = col_fun1, rownames.side = \"inside\") circos.clear() text(0, 0, 'rownames.side = \"inside\"') ccHeatmap(mat = mat1, split = split, col = col_fun1, rownames.side = \"outside\") circos.clear() text(0, 0, 'rownames.side = \"outside\"') Circular heatmap. Control the row names. ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\", rownames.side = \"outside\") circos.clear() ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"outside\", rownames.side = \"inside\") circos.clear() Circular heatmap. Control both the dendrograms and row names. ccHeatmap(mat = mat1, split = split, col = col_fun1, rownames.side = \"outside\", rownames.col = 1:nrow(mat1) %% 10 + 1, rownames.cex = runif(nrow(mat1), min = 0.3, max = 2), rownames.font = 1:nrow(mat1) %% 4 + 1) Circular heatmap. Control graphic parameters for row names. circos.clear()","title":"Dendrograms and row names"},{"location":"06-circos-heatmap/#clustering","text":"ccHeatmap(mat = mat1, split = split, cluster = FALSE, col = col_fun1) circos.clear() Circular heatmap. Control clusterings.","title":"Clustering"},{"location":"06-circos-heatmap/#callback-on-dendrograms","text":"function(dend, m, si) reorder(dend, rowMeans(m)) library(dendsort) ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\", dend.callback = function(dend, m, si) { dendsort(dend) } ) circos.clear() Circular Heatmap. Reorder dendrograms. library(dendextend) dend_col = structure(1:5, names = letters[1:5]) ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"inside\", dend.track.height = 0.2, dend.callback = function(dend, m, si) { # when k = 1, it renders one same color for the whole dendrogram color_branches(dend, k = 1, col = dend_col[si]) } ) Circular heatmap. Render dendrograms that were split. circos.clear() ccHeatmap(mat = mat1, col = col_fun1, dend.side = \"inside\", dend.track.height = 0.2, dend.callback = function(dend, m, si) { color_branches(dend, k = 4, col = 2:5) } ) Circular heatmap. Render dendrograms. circos.clear()","title":"Callback on dendrograms"},{"location":"06-circos-heatmap/#multiple-heatmap-tracks","text":"mat2 = mat1[sample(100, 100), ] # randomly permute mat1 by rows col_fun2 = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")) hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1, dend.side = \"outside\") hm2 = ccHeatmap(mat = mat2, col = col_fun2) hm1 + hm2 circos.clear() hm1 = ccHeatmap(mat = mat2, split = split, col = col_fun2, dend.side = \"outside\") hm2 = ccHatmap(mat = mat1, col = col_fun1) hm1 + hm2 circos.clear() cc = ccPlot(initFunc='heatmap.initialize', mat = mat1, split = split) hm1 = ccHeatmap(mat = mat2, col = col_fun2, dend.side = \"outside\") hm2 = ccHeatmap(mat = mat1, col = col_fun1) cc + hm1 + hm2 circos.clear() cc = ccPlot(initFunc='heatmap.initialize', mat = mat1, split = split) hm1 = ccHeatmap(mat = mat1[, 1:5], col = col_fun1) hm2 = ccHeatmap(mat = mat1[, 6:10], col = col_fun1) cc + hm1 + hm2 circos.clear()","title":"Multiple heatmap tracks"},{"location":"06-circos-heatmap/#with-other-tracks","text":"CELL_META$row_dend ## 'dendrogram' with 2 branches and 14 members total, at height 10.51736 CELL_META$row_order ## [1] 2 6 4 12 8 1 5 10 7 9 13 11 3 14 CELL_META$subset ## [1] 8 9 14 18 20 37 55 62 66 72 78 85 93 97 hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) row_mean = rowMeans(mat1[, 1:5]) t1 = ccTrack(ylim = range(row_mean), panel.fun = function(x, y) { y = row_mean[CELL_META$subset] y = y[CELL_META$row_order] circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"grey\") circos.points(seq_along(y) - 0.5, y, col = ifelse(y > 0, \"red\", \"blue\")) }, cell.padding = c(0.02, 0, 0.02, 0)) hm1 + t1 circos.clear() cc = ccPlot(initFunc='heatmap.initialize', mat = mat1, split = split) # This is the same as the previous example t1 = ccTrack(ylim = range(row_mean), panel.fun = function(x, y) { y = row_mean[CELL_META$subset] y = y[CELL_META$row_order] circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"grey\") circos.points(seq_along(y) - 0.5, y, col = ifelse(y > 0, \"red\", \"blue\")) }, cell.padding = c(0.02, 0, 0.02, 0)) hm1 = ccHeatmap(mat1, col = col_fun1) # no need to specify 'split' here cc + t1 + hm1 circos.clear() hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) t1 = ccTrack(ylim = range(mat1), panel.fun = function(x, y) { m = mat1[CELL_META$subset, 1:5, drop = FALSE] m = m[CELL_META$row_order, , drop = FALSE] n = nrow(m) # circos.boxplot is applied on matrix columns, so here we transpose it. circos.boxplot(t(m), pos = 1:n - 0.5, pch = 16, cex = 0.3) circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"grey\") }, cell.padding = c(0.02, 0, 0.02, 0)) hm1 + t1 circos.clear()","title":"With other tracks"},{"location":"06-circos-heatmap/#add-annotations","text":"hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) hm1 circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + convert_y(2, \"mm\"), paste0(\"this is group \", CELL_META$sector.index), facing = \"bending.inside\", cex = 0.8, adj = c(0.5, 0), niceFacing = TRUE) }, bg.border = NA) circos.clear() par1 = ccPar(gap.after = c(2, 2, 2, 2, 10)) hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1, track.height = 0.4) hm1 + par1 circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { if(CELL_META$sector.numeric.index == 5) { # the last sector cn = colnames(mat1) n = length(cn) circos.text(rep(CELL_META$cell.xlim[2], n) + convert_x(1, \"mm\"), 1:n - 0.5, cn, cex = 0.5, adj = c(0, 0.5), facing = \"inside\") } }, bg.border = NA) circos.clear() par1 = ccPar(gap.after = c(2, 2, 2, 2, 10)) hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1, track.height = 0.4) hm1 + par1 circos.track(track.index = get.current.track.index(), panel.fun = function(x, y) { if(CELL_META$sector.numeric.index == 5) { # the last sector circos.rect(CELL_META$cell.xlim[2] + convert_x(1, \"mm\"), 0, CELL_META$cell.xlim[2] + convert_x(5, \"mm\"), 5, col = \"orange\", border = NA) circos.text(CELL_META$cell.xlim[2] + convert_x(3, \"mm\"), 2.5, \"group 1\", cex = 0.5, facing = \"clockwise\") circos.rect(CELL_META$cell.xlim[2] + convert_x(1, \"mm\"), 5, CELL_META$cell.xlim[2] + convert_x(5, \"mm\"), 10, col = \"pink\", border = NA) circos.text(CELL_META$cell.xlim[2] + convert_x(3, \"mm\"), 7.5, \"group 2\", cex = 0.5, facing = \"clockwise\") } }, bg.border = NA) circos.clear() hm1 = ccHeatmap(mat = mat1, split = split, col = col_fun1) hm1 circos.clear() library(ComplexHeatmap) lgd = Legend(title = \"mat1\", col_fun = col_fun1) grid.draw(lgd)","title":"Add annotations"},{"location":"06-circos-heatmap/#a-complex-example-of-circular-heatmaps","text":"source(\"https://gist.githubusercontent.com/jokergoo/0ea5639ee25a7edae3871ed8252924a1/raw/57ca9426c2ed0cebcffd79db27a024033e5b8d52/random_matrices.R\") set.seed(123) km = kmeans(mat_meth, centers = 5)$cluster col_meth = colorRamp2(c(0, 0.5, 1), c(\"blue\", \"white\", \"red\")) hm1 = ccHeatmap(mat = mat_meth, split = km, col = col_meth, track.height = 0.12) col_direction = c(\"hyper\" = \"red\", \"hypo\" = \"blue\") hm2 = ccHeatmap(mat = direction, col = col_direction, track.height = 0.01) col_expr = colorRamp2(c(-2, 0, 2), c(\"green\", \"white\", \"red\")) hm3 = ccHeatmap(mat = mat_expr, col = col_expr, track.height = 0.12) col_pvalue = colorRamp2(c(0, 2, 4), c(\"white\", \"white\", \"red\")) hm4 = ccHeatmap(mat = cor_pvalue, col = col_pvalue, track.height = 0.01) library(RColorBrewer) col_gene_type = structure(brewer.pal(length(unique(gene_type)), \"Set3\"), names = unique(gene_type)) hm5 = ccHeatmap(mat = gene_type, col = col_gene_type, track.height = 0.01) col_anno_gene = structure(brewer.pal(length(unique(anno_gene)), \"Set1\"), names = unique(anno_gene)) hm6 = ccHeatmap(mat = anno_gene, col = col_anno_gene, track.height = 0.01) col_dist = colorRamp2(c(0, 10000), c(\"black\", \"white\")) hm7 = ccHeatmap(mat = dist, col = col_dist, track.height = 0.01) col_enhancer = colorRamp2(c(0, 1), c(\"white\", \"orange\")) hm8 = ccHeatmap(mat = anno_enhancer, col = col_enhancer, track.height = 0.03) cc = hm1 + hm2 + hm3 + hm4 + hm5 + hm6 + hm7 + hm8 cc circos.clear() df_link = data.frame( from_index = sample(nrow(mat_meth), 20), to_index = sample(nrow(mat_meth), 20) ) for(i in seq_len(nrow(df_link))) { # Let's call the DMR with index df_link$from_index[i] as DMR1, # and the other one with index df_link$to_index[i] as DMR2. # The sector where DMR1 is in. group1 = km[ df_link$from_index[i] ] # The sector where DMR2 is in. group2 = km[ df_link$to_index[i] ] # The subset of DMRs (row indices from mat_meth) in sector `group1`. subset1 = get.cell.meta.data(\"subset\", sector.index = group1) # The row ordering in sector `group1`. row_order1 = get.cell.meta.data(\"row_order\", sector.index = group1) # This is the position of DMR1 in the `group1` heatmap. x1 = which(subset1[row_order1] == df_link$from_index[i]) # The subset of DMRs (row indices from mat_meth) in sector `group2`. subset2 = get.cell.meta.data(\"subset\", sector.index = group2) # The row ordering in sector `group2`. row_order2 = get.cell.meta.data(\"row_order\", sector.index = group2) # This is the position of DMR2 in the `group2` heatmap. x2 = which(subset2[row_order2] == df_link$to_index[i]) # We take the middle point and draw a link between DMR1 and DMR2 cc = cc + ccLink(group1, x1 - 0.5, group2, x2 - 0.5, col = rand_color(1)) } cc for(i in seq_len(nrow(df_link))) { cc = cc + ccHeatmapLink(df_link$from_index[i], df_link$to_index[i], col = rand_color(1)) } cc circlize_plot = function() { hm1 = ccHeatmap(mat = mat_meth, split = km, col = col_meth, track.height = 0.12) hm2 = ccHeatmap(mat = direction, col = col_direction, track.height = 0.01) hm3 = ccHeatmap(mat = mat_expr, col = col_expr, track.height = 0.12) hm4 = ccHeatmap(mat = cor_pvalue, col = col_pvalue, track.height = 0.01) hm5 = ccHeatmap(mat = gene_type, col = col_gene_type, track.height = 0.01) hm6 = ccHeatmap(mat = anno_gene, col = col_anno_gene, track.height = 0.01) hm7 = ccHeatmap(mat = dist, col = col_dist, track.height = 0.01) hm8 = ccHeatmap(mat = anno_enhancer, col = col_enhancer, track.height = 0.03) cc = hm1 + hm2 + hm3 + hm4 + hm5 + hm6 + hm7 + hm8 for(i in seq_len(nrow(df_link))) { cc = cc + ccHeatmapLink(df_link$from_index[i], df_link$to_index[i], col = rand_color(1)) } show(cc) circos.clear() } lgd_meth = Legend(title = \"Methylation\", col_fun = col_meth) lgd_direction = Legend(title = \"Direction\", at = names(col_direction), legend_gp = gpar(fill = col_direction)) lgd_expr = Legend(title = \"Expression\", col_fun = col_expr) lgd_pvalue = Legend(title = \"P-value\", col_fun = col_pvalue, at = c(0, 2, 4), labels = c(1, 0.01, 0.0001)) lgd_gene_type = Legend(title = \"Gene type\", at = names(col_gene_type), legend_gp = gpar(fill = col_gene_type)) lgd_anno_gene = Legend(title = \"Gene anno\", at = names(col_anno_gene), legend_gp = gpar(fill = col_anno_gene)) lgd_dist = Legend(title = \"Dist to TSS\", col_fun = col_dist, at = c(0, 5000, 10000), labels = c(\"0kb\", \"5kb\", \"10kb\")) lgd_enhancer = Legend(title = \"Enhancer overlap\", col_fun = col_enhancer, at = c(0, 0.25, 0.5, 0.75, 1), labels = c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\")) library(gridBase) plot.new() circle_size = unit(1, \"snpc\") # snpc unit gives you a square region pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size, just = c(\"left\", \"center\"))) par(omi = gridOMI(), new = TRUE) circlize_plot() upViewport() h = dev.size()[2] lgd_list = packLegend(lgd_meth, lgd_direction, lgd_expr, lgd_pvalue, lgd_gene_type, lgd_anno_gene, lgd_dist, lgd_enhancer, max_height = unit(0.9*h, \"inch\")) draw(lgd_list, x = circle_size, just = \"left\")","title":"A complex example of circular heatmaps"},{"location":"07-advanced-usage/","text":"Advanced layout Zooming of sectors set.seed(123) df = data.frame( sectors = sample(letters[1:6], 400, replace = TRUE), x = rnorm(400), y = rnorm(400), stringsAsFactors = FALSE ) zoom_df_a = df[df$sectors == \"a\", ] zoom_df_b = df[df$sectors == \"b\", ] zoom_df_b = zoom_df_b[order(zoom_df_b[, 2])[1:10], ] zoom_df = rbind(zoom_df_a, zoom_df_b) zoom_df$sectors = paste0(\"zoom_\", zoom_df$sectors) df2 = rbind(df, zoom_df) xrange = tapply(df2$x, df2$sectors, function(x) max(x) - min(x)) normal_sector_index = unique(df$sectors) zoomed_sector_index = unique(zoom_df$sectors) sector.width = c(xrange[normal_sector_index] / sum(xrange[normal_sector_index]), xrange[zoomed_sector_index] / sum(xrange[zoomed_sector_index])) sector.width par1 = ccPar(start.degree = 90, points.overflow.warning = FALSE) cc = ccPlot(sectors = df2$sectors, x = df2$x, sector.width = sector.width) t1 = ccTrack(sectors = df2$sectors, x = df2$x, y = df2$y, panel.fun = function(x, y) { circos.points(x, y, col = \"red\", pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + mm_y(2), CELL_META$sector.index, niceFacing = TRUE) }) l1 = ccLink(\"a\", get.cell.meta.data(\"cell.xlim\", sector.index = \"a\"), \"zoom_a\", get.cell.meta.data(\"cell.xlim\", sector.index = \"zoom_a\"), border = NA, col = \"#00000020\") l2 = ccLink(\"b\", c(zoom_df_b[1, 2], zoom_df_b[10, 2]), \"zoom_b\", get.cell.meta.data(\"cell.xlim\", sector.index = \"zoom_b\"), rou1 = get.cell.meta.data(\"cell.top.radius\", sector.index = \"b\"), border = NA, col = \"#00000020\") cc + par1 + t1 + l1 + l2 circos.clear() Zoom sectors. Visualize part of the circle sectors = letters[1:4] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) # directly specify the subset of data df = data.frame(sectors = rep(\"a\", 100), x = runif(100), y = runif(100)) t1 = ccTrack(df$sectors, x = df$x, y = df$y, panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) # create empty track first then fill graphics in the cell t2 = ccTrack(ylim = range(df$y), bg.border = NA) cc + t1 + t2 circos.update(sector.index = \"a\", bg.border = \"black\") circos.points(df$x, df$y, pch = 16, cex = 0.5) circos.track(sectors = sectors, ylim = c(0, 1)) circos.track(sectors = sectors, ylim = c(0, 1)) (\\#fig:circlize-part2)Show subset of cells in tracks. circos.clear() Combine multiple circular plots sectors = letters[1:4] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, \"outer circos\", niceFacing = TRUE) }) cc + t1 circos.clear() par(new = TRUE) # <- magic par1 = ccPar(\"canvas.xlim\" = c(-2, 2), \"canvas.ylim\" = c(-2, 2)) sectors = letters[1:3] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, \"inner circos\", niceFacing = TRUE) }) cc + t1 circos.clear() Nested circular plots. sectors = letters[1:4] lim = c(1, 1.1, 1.2, 1.3) for(i in 1:4) { par1 = ccPar(\"canvas.xlim\" = c(-lim[i], lim[i]), \"canvas.ylim\" = c(-lim[i], lim[i]), \"track.height\" = 0.4) cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), bg.border = NA) show(cc + par1 + t1) circos.update(sector.index = sectors[i], bg.border = \"black\") circos.points(runif(10), runif(10), pch = 16) circos.clear() par(new = TRUE) } par(new = FALSE) Cells with differnet radius. Arrange multiple plots layout(matrix(1:9, 3, 3)) for(i in 1:9) { sectors = 1:8 par(mar = c(0.5, 0.5, 0.5, 0.5)) par1 = ccPar(cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), track.height = 0.05, bg.col = rand_color(8), bg.border = NA) cc = cc + par1 + t1 for(i in 1:20) { se = sample(1:8, 2) l = ccLink(se[1], runif(2), se[2], runif(2), col = rand_color(1, transparency = 0.4), border = NA) cc = cc + l } show(cc) circos.clear() } Arrange multiple circular plots.","title":"Advanced layout"},{"location":"07-advanced-usage/#advanced-layout","text":"","title":"Advanced layout"},{"location":"07-advanced-usage/#zooming-of-sectors","text":"set.seed(123) df = data.frame( sectors = sample(letters[1:6], 400, replace = TRUE), x = rnorm(400), y = rnorm(400), stringsAsFactors = FALSE ) zoom_df_a = df[df$sectors == \"a\", ] zoom_df_b = df[df$sectors == \"b\", ] zoom_df_b = zoom_df_b[order(zoom_df_b[, 2])[1:10], ] zoom_df = rbind(zoom_df_a, zoom_df_b) zoom_df$sectors = paste0(\"zoom_\", zoom_df$sectors) df2 = rbind(df, zoom_df) xrange = tapply(df2$x, df2$sectors, function(x) max(x) - min(x)) normal_sector_index = unique(df$sectors) zoomed_sector_index = unique(zoom_df$sectors) sector.width = c(xrange[normal_sector_index] / sum(xrange[normal_sector_index]), xrange[zoomed_sector_index] / sum(xrange[zoomed_sector_index])) sector.width par1 = ccPar(start.degree = 90, points.overflow.warning = FALSE) cc = ccPlot(sectors = df2$sectors, x = df2$x, sector.width = sector.width) t1 = ccTrack(sectors = df2$sectors, x = df2$x, y = df2$y, panel.fun = function(x, y) { circos.points(x, y, col = \"red\", pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + mm_y(2), CELL_META$sector.index, niceFacing = TRUE) }) l1 = ccLink(\"a\", get.cell.meta.data(\"cell.xlim\", sector.index = \"a\"), \"zoom_a\", get.cell.meta.data(\"cell.xlim\", sector.index = \"zoom_a\"), border = NA, col = \"#00000020\") l2 = ccLink(\"b\", c(zoom_df_b[1, 2], zoom_df_b[10, 2]), \"zoom_b\", get.cell.meta.data(\"cell.xlim\", sector.index = \"zoom_b\"), rou1 = get.cell.meta.data(\"cell.top.radius\", sector.index = \"b\"), border = NA, col = \"#00000020\") cc + par1 + t1 + l1 + l2 circos.clear() Zoom sectors.","title":"Zooming of sectors"},{"location":"07-advanced-usage/#visualize-part-of-the-circle","text":"sectors = letters[1:4] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) # directly specify the subset of data df = data.frame(sectors = rep(\"a\", 100), x = runif(100), y = runif(100)) t1 = ccTrack(df$sectors, x = df$x, y = df$y, panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) # create empty track first then fill graphics in the cell t2 = ccTrack(ylim = range(df$y), bg.border = NA) cc + t1 + t2 circos.update(sector.index = \"a\", bg.border = \"black\") circos.points(df$x, df$y, pch = 16, cex = 0.5) circos.track(sectors = sectors, ylim = c(0, 1)) circos.track(sectors = sectors, ylim = c(0, 1)) (\\#fig:circlize-part2)Show subset of cells in tracks. circos.clear()","title":"Visualize part of the circle"},{"location":"07-advanced-usage/#combine-multiple-circular-plots","text":"sectors = letters[1:4] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, \"outer circos\", niceFacing = TRUE) }) cc + t1 circos.clear() par(new = TRUE) # <- magic par1 = ccPar(\"canvas.xlim\" = c(-2, 2), \"canvas.ylim\" = c(-2, 2)) sectors = letters[1:3] cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, \"inner circos\", niceFacing = TRUE) }) cc + t1 circos.clear() Nested circular plots. sectors = letters[1:4] lim = c(1, 1.1, 1.2, 1.3) for(i in 1:4) { par1 = ccPar(\"canvas.xlim\" = c(-lim[i], lim[i]), \"canvas.ylim\" = c(-lim[i], lim[i]), \"track.height\" = 0.4) cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), bg.border = NA) show(cc + par1 + t1) circos.update(sector.index = sectors[i], bg.border = \"black\") circos.points(runif(10), runif(10), pch = 16) circos.clear() par(new = TRUE) } par(new = FALSE) Cells with differnet radius.","title":"Combine multiple circular plots"},{"location":"07-advanced-usage/#arrange-multiple-plots","text":"layout(matrix(1:9, 3, 3)) for(i in 1:9) { sectors = 1:8 par(mar = c(0.5, 0.5, 0.5, 0.5)) par1 = ccPar(cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = sectors, xlim = c(0, 1)) t1 = ccTrack(ylim = c(0, 1), track.height = 0.05, bg.col = rand_color(8), bg.border = NA) cc = cc + par1 + t1 for(i in 1:20) { se = sample(1:8, 2) l = ccLink(se[1], runif(2), se[2], runif(2), col = rand_color(1, transparency = 0.4), border = NA) cc = cc + l } show(cc) circos.clear() } Arrange multiple circular plots.","title":"Arrange multiple plots"},{"location":"09-initialize-genomic-data/","text":"Initialize with genomic data circlize is quite flexible to initialize the circular plot not only by chromosomes, but also by any type of general genomic categories. Initialize with cytoband data Basic usage ccPlot(initFunc='initializeWithIdeogram') text(0, 0, \"default\", cex = 1) Initialize genomic plot, default. cytoband.file = system.file(package = \"circlize\", \"extdata\", \"cytoBand.txt\") cc = ccPlot(initFunc='initializeWithIdeogram', cytoband = cytoband.file) cc cytoband.df = read.table(cytoband.file, colClasses = c(\"character\", \"numeric\", \"numeric\", \"character\", \"character\"), sep = \"\\t\") cc = ccPlot(initFunc='initializeWithIdeogram', cytoband = cytoband.df) cc cc = ccPlot(initFunc='initializeWithIdeogram', chromosome.index = paste0(\"chr\", c(3,5,2,8))) cc text(0, 0, \"subset of chromosomes\", cex = 1) Initialize genomic plot, subset chromosomes. circos.clear() Pre-defined tracks cc = ccPlot(initFunc='initializeWithIdeogram', plotType = c(\"axis\", \"labels\")) cc text(0, 0, \"plotType = c('axis', 'labels')\", cex = 1) circos.clear() cc = ccPlot(initFunc='initializeWithIdeogram', plotType = NULL) cc text(0, 0, \"plotType = NULL\", cex = 1) Initialize genomic plot, control tracks. circos.clear() Other general settings par1 = ccPar(\"start.degree\" = 90) cc = ccPlot(initFunc='initializeWithIdeogram') cc + par1 circos.clear() text(0, 0, \"'start.degree' = 90\", cex = 1) par1 = ccPar(\"gap.degree\" = rep(c(2, 4), 12)) cc = ccPlot(initFunc='initializeWithIdeogram') cc + par1 circos.clear() text(0, 0, \"'gap.degree' = rep(c(2, 4), 12)\", cex = 1) Initialize genomic plot, control layout. Customize chromosome track set.seed(123) cc = ccPlot(initFunc='initializeWithIdeogram', plotType = NULL) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { chr = CELL_META$sector.index xlim = CELL_META$xlim ylim = CELL_META$ylim circos.rect(xlim[1], 0, xlim[2], 1, col = rand_color(1)) circos.text(mean(xlim), mean(ylim), chr, cex = 0.7, col = \"white\", facing = \"inside\", niceFacing = TRUE) }, track.height = 0.15, bg.border = NA) cc + t1 Customize chromosome track. circos.clear() Initialize with general genomic category tp_family = readRDS(system.file(package = \"circlize\", \"extdata\", \"tp_family_df.rds\")) head(tp_family) cc = ccPlot(initFunc = 'initializeWithIdeogram', cytoband = tp_family) t1 = ccTrack(ylim = c(0, 1), bg.col = c(\"#FF000040\", \"#00FF0040\", \"#0000FF40\"), bg.border = NA, track.height = 0.05) n = max(tapply(tp_family$transcript, tp_family$gene, function(x) length(unique(x)))) t2 = ccGenomicTrack(data = tp_family, ylim = c(0.5, n + 0.5), panel.fun = function(region, value, ...) { all_tx = unique(value$transcript) for(i in seq_along(all_tx)) { l = value$transcript == all_tx[i] # for each transcript current_tx_start = min(region[l, 1]) current_tx_end = max(region[l, 2]) circos.lines(c(current_tx_start, current_tx_end), c(n - i + 1, n - i + 1), col = \"#CCCCCC\") circos.genomicRect(region[l, , drop = FALSE], ytop = n - i + 1 + 0.4, ybottom = n - i + 1 - 0.4, col = \"orange\", border = NA) } }, bg.border = NA, track.height = 0.4) cc + t1 + t2 circos.clear() Circular representation of alternative transcripts for genes. Zooming chromosomes extend_chromosomes = function(bed, chromosome, prefix = \"zoom_\") { zoom_bed = bed[bed[[1]] %in% chromosome, , drop = FALSE] zoom_bed[[1]] = paste0(prefix, zoom_bed[[1]]) rbind(bed, zoom_bed) } cytoband = read.cytoband() cytoband_df = cytoband$df chromosome = cytoband$chromosome xrange = c(cytoband$chr.len, cytoband$chr.len[c(\"chr1\", \"chr2\")]) normal_chr_index = 1:24 zoomed_chr_index = 25:26 # normalize in normal chromsomes and zoomed chromosomes separately sector.width = c(xrange[normal_chr_index] / sum(xrange[normal_chr_index]), xrange[zoomed_chr_index] / sum(xrange[zoomed_chr_index])) par1 = ccPar(start.degree = 90) cc = ccPlot(initFunc = 'initializeWithIdeogram', cytoband = extend_chromosomes(cytoband_df, c(\"chr1\", \"chr2\")), sector.width = sector.width) bed = generateRandomBed(500) t1 = ccGenomicTrack(extend_chromosomes(bed, c(\"chr1\", \"chr2\")), panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.3) }) cc + par1 + t1 circos.link(\"chr1\", get.cell.meta.data(\"cell.xlim\", sector.index = \"chr1\"), \"zoom_chr1\", get.cell.meta.data(\"cell.xlim\", sector.index = \"zoom_chr1\"), col = \"#00000020\", border = NA) circos.clear() Zoom chromosomes. Concatenating two genomes human_cytoband = read.cytoband(species = \"hg19\")$df mouse_cytoband = read.cytoband(species = \"mm10\")$df human_cytoband[ ,1] = paste0(\"human_\", human_cytoband[, 1]) mouse_cytoband[ ,1] = paste0(\"mouse_\", mouse_cytoband[, 1]) cytoband = rbind(human_cytoband, mouse_cytoband) head(cytoband) chromosome.index = c(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), rev(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")))) ccPlot(initFunc = \"initializeWithIdeogram\", cytoband = cytoband, chromosome.index = chromosome.index) Default style of two combined genomes. circos.clear() par1 = ccPar(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) cc = ccPlot(initFunc = \"initializeWithIdeogram\", cytoband = cytoband, plotType = NULL, chromosome.index = chromosome.index) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(\".*chr\", \"\", CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) t2 = ccGenomicIdeogram(cytoband) cc + par1 + t1 + t2 highlight.chromosome(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), col = \"red\", track.index = 1) highlight.chromosome(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")), col = \"blue\", track.index = 1) (\\#fig:genomic-combined-improved)Improved visualization of the combined genome. circos.clear() human_chromInfo = read.chromInfo(species = \"hg19\")$df mouse_chromInfo = read.chromInfo(species = \"mm10\")$df human_chromInfo[ ,1] = paste0(\"human_\", human_chromInfo[, 1]) mouse_chromInfo[ ,1] = paste0(\"mouse_\", mouse_chromInfo[, 1]) chromInfo = rbind(human_chromInfo, mouse_chromInfo) # note the levels of the factor controls the chromosome orders in the plot chromInfo[, 1] = factor(chromInfo[ ,1], levels = chromosome.index) head(chromInfo) par1 = ccPar(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) cc = ccPlot(initFunc = \"genomicInitialize\", data = chromInfo, plotType = NULL) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(\".*chr\", \"\", CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) t2 = ccTrack(ylim = c(0, 1)) cc + par1 + t1 + t2 highlight.chromosome(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), col = \"red\", track.index = 1) highlight.chromosome(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")), col = \"blue\", track.index = 1) Initialize the plot with chromosome ranges. circos.clear() par1 = ccPar(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) cc = ccPlot(initFunc = \"genomicInitialize\", data = chromInfo, plotType = NULL) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(\".*chr\", \"\", CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) t2 = ccGenomicIdeogram(cytoband = cytoband) highlight.chromosome(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), col = \"red\", track.index = 1) highlight.chromosome(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")), col = \"blue\", track.index = 1) # a track of points human_df = generateRandomBed(200, species = \"hg19\") mouse_df = generateRandomBed(200, species = \"mm10\") human_df[ ,1] = paste0(\"human_\", human_df[, 1]) mouse_df[ ,1] = paste0(\"mouse_\", mouse_df[, 1]) df = rbind(human_df, mouse_df) t3 = ccGenomicTrack(df, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, col = rand_color(1), cex = 0.5, ...) }) # links between human and mouse genomes human_mid = data.frame( chr = paste0(\"human_chr\", 1:19), mid = round((human_chromInfo[1:19, 2] + human_chromInfo[1:19, 3])/2) ) mouse_mid = data.frame( chr = paste0(\"mouse_chr\", 1:19), mid = round((mouse_chromInfo[1:19, 2] + mouse_chromInfo[1:19, 3])/2) ) l1 = ccGenomicLink(human_mid, mouse_mid, col = rand_color(19)) cc + par1 + t1 + t2 + t3 + l1 circos.clear() text(-0.9, -0.8, \"Human\\ngenome\") text(0.9, 0.8, \"Mouse\\ngenome\") The combined genome with more tracks.","title":"Initialize with genomic data"},{"location":"09-initialize-genomic-data/#initialize-with-genomic-data","text":"circlize is quite flexible to initialize the circular plot not only by chromosomes, but also by any type of general genomic categories.","title":"Initialize with genomic data"},{"location":"09-initialize-genomic-data/#initialize-with-cytoband-data","text":"","title":"Initialize with cytoband data"},{"location":"09-initialize-genomic-data/#basic-usage","text":"ccPlot(initFunc='initializeWithIdeogram') text(0, 0, \"default\", cex = 1) Initialize genomic plot, default. cytoband.file = system.file(package = \"circlize\", \"extdata\", \"cytoBand.txt\") cc = ccPlot(initFunc='initializeWithIdeogram', cytoband = cytoband.file) cc cytoband.df = read.table(cytoband.file, colClasses = c(\"character\", \"numeric\", \"numeric\", \"character\", \"character\"), sep = \"\\t\") cc = ccPlot(initFunc='initializeWithIdeogram', cytoband = cytoband.df) cc cc = ccPlot(initFunc='initializeWithIdeogram', chromosome.index = paste0(\"chr\", c(3,5,2,8))) cc text(0, 0, \"subset of chromosomes\", cex = 1) Initialize genomic plot, subset chromosomes. circos.clear()","title":"Basic usage"},{"location":"09-initialize-genomic-data/#pre-defined-tracks","text":"cc = ccPlot(initFunc='initializeWithIdeogram', plotType = c(\"axis\", \"labels\")) cc text(0, 0, \"plotType = c('axis', 'labels')\", cex = 1) circos.clear() cc = ccPlot(initFunc='initializeWithIdeogram', plotType = NULL) cc text(0, 0, \"plotType = NULL\", cex = 1) Initialize genomic plot, control tracks. circos.clear()","title":"Pre-defined tracks"},{"location":"09-initialize-genomic-data/#other-general-settings","text":"par1 = ccPar(\"start.degree\" = 90) cc = ccPlot(initFunc='initializeWithIdeogram') cc + par1 circos.clear() text(0, 0, \"'start.degree' = 90\", cex = 1) par1 = ccPar(\"gap.degree\" = rep(c(2, 4), 12)) cc = ccPlot(initFunc='initializeWithIdeogram') cc + par1 circos.clear() text(0, 0, \"'gap.degree' = rep(c(2, 4), 12)\", cex = 1) Initialize genomic plot, control layout.","title":"Other general settings"},{"location":"09-initialize-genomic-data/#customize-chromosome-track","text":"set.seed(123) cc = ccPlot(initFunc='initializeWithIdeogram', plotType = NULL) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { chr = CELL_META$sector.index xlim = CELL_META$xlim ylim = CELL_META$ylim circos.rect(xlim[1], 0, xlim[2], 1, col = rand_color(1)) circos.text(mean(xlim), mean(ylim), chr, cex = 0.7, col = \"white\", facing = \"inside\", niceFacing = TRUE) }, track.height = 0.15, bg.border = NA) cc + t1 Customize chromosome track. circos.clear()","title":"Customize chromosome track"},{"location":"09-initialize-genomic-data/#initialize-with-general-genomic-category","text":"tp_family = readRDS(system.file(package = \"circlize\", \"extdata\", \"tp_family_df.rds\")) head(tp_family) cc = ccPlot(initFunc = 'initializeWithIdeogram', cytoband = tp_family) t1 = ccTrack(ylim = c(0, 1), bg.col = c(\"#FF000040\", \"#00FF0040\", \"#0000FF40\"), bg.border = NA, track.height = 0.05) n = max(tapply(tp_family$transcript, tp_family$gene, function(x) length(unique(x)))) t2 = ccGenomicTrack(data = tp_family, ylim = c(0.5, n + 0.5), panel.fun = function(region, value, ...) { all_tx = unique(value$transcript) for(i in seq_along(all_tx)) { l = value$transcript == all_tx[i] # for each transcript current_tx_start = min(region[l, 1]) current_tx_end = max(region[l, 2]) circos.lines(c(current_tx_start, current_tx_end), c(n - i + 1, n - i + 1), col = \"#CCCCCC\") circos.genomicRect(region[l, , drop = FALSE], ytop = n - i + 1 + 0.4, ybottom = n - i + 1 - 0.4, col = \"orange\", border = NA) } }, bg.border = NA, track.height = 0.4) cc + t1 + t2 circos.clear() Circular representation of alternative transcripts for genes.","title":"Initialize with general genomic category"},{"location":"09-initialize-genomic-data/#zooming-chromosomes","text":"extend_chromosomes = function(bed, chromosome, prefix = \"zoom_\") { zoom_bed = bed[bed[[1]] %in% chromosome, , drop = FALSE] zoom_bed[[1]] = paste0(prefix, zoom_bed[[1]]) rbind(bed, zoom_bed) } cytoband = read.cytoband() cytoband_df = cytoband$df chromosome = cytoband$chromosome xrange = c(cytoband$chr.len, cytoband$chr.len[c(\"chr1\", \"chr2\")]) normal_chr_index = 1:24 zoomed_chr_index = 25:26 # normalize in normal chromsomes and zoomed chromosomes separately sector.width = c(xrange[normal_chr_index] / sum(xrange[normal_chr_index]), xrange[zoomed_chr_index] / sum(xrange[zoomed_chr_index])) par1 = ccPar(start.degree = 90) cc = ccPlot(initFunc = 'initializeWithIdeogram', cytoband = extend_chromosomes(cytoband_df, c(\"chr1\", \"chr2\")), sector.width = sector.width) bed = generateRandomBed(500) t1 = ccGenomicTrack(extend_chromosomes(bed, c(\"chr1\", \"chr2\")), panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.3) }) cc + par1 + t1 circos.link(\"chr1\", get.cell.meta.data(\"cell.xlim\", sector.index = \"chr1\"), \"zoom_chr1\", get.cell.meta.data(\"cell.xlim\", sector.index = \"zoom_chr1\"), col = \"#00000020\", border = NA) circos.clear() Zoom chromosomes.","title":"Zooming chromosomes"},{"location":"09-initialize-genomic-data/#concatenating-two-genomes","text":"human_cytoband = read.cytoband(species = \"hg19\")$df mouse_cytoband = read.cytoband(species = \"mm10\")$df human_cytoband[ ,1] = paste0(\"human_\", human_cytoband[, 1]) mouse_cytoband[ ,1] = paste0(\"mouse_\", mouse_cytoband[, 1]) cytoband = rbind(human_cytoband, mouse_cytoband) head(cytoband) chromosome.index = c(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), rev(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")))) ccPlot(initFunc = \"initializeWithIdeogram\", cytoband = cytoband, chromosome.index = chromosome.index) Default style of two combined genomes. circos.clear() par1 = ccPar(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) cc = ccPlot(initFunc = \"initializeWithIdeogram\", cytoband = cytoband, plotType = NULL, chromosome.index = chromosome.index) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(\".*chr\", \"\", CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) t2 = ccGenomicIdeogram(cytoband) cc + par1 + t1 + t2 highlight.chromosome(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), col = \"red\", track.index = 1) highlight.chromosome(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")), col = \"blue\", track.index = 1) (\\#fig:genomic-combined-improved)Improved visualization of the combined genome. circos.clear() human_chromInfo = read.chromInfo(species = \"hg19\")$df mouse_chromInfo = read.chromInfo(species = \"mm10\")$df human_chromInfo[ ,1] = paste0(\"human_\", human_chromInfo[, 1]) mouse_chromInfo[ ,1] = paste0(\"mouse_\", mouse_chromInfo[, 1]) chromInfo = rbind(human_chromInfo, mouse_chromInfo) # note the levels of the factor controls the chromosome orders in the plot chromInfo[, 1] = factor(chromInfo[ ,1], levels = chromosome.index) head(chromInfo) par1 = ccPar(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) cc = ccPlot(initFunc = \"genomicInitialize\", data = chromInfo, plotType = NULL) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(\".*chr\", \"\", CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) t2 = ccTrack(ylim = c(0, 1)) cc + par1 + t1 + t2 highlight.chromosome(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), col = \"red\", track.index = 1) highlight.chromosome(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")), col = \"blue\", track.index = 1) Initialize the plot with chromosome ranges. circos.clear() par1 = ccPar(gap.after = c(rep(1, 23), 5, rep(1, 20), 5)) cc = ccPlot(initFunc = \"genomicInitialize\", data = chromInfo, plotType = NULL) t1 = ccTrack(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), gsub(\".*chr\", \"\", CELL_META$sector.index), cex = 0.6, niceFacing = TRUE) }, track.height = mm_h(1), cell.padding = c(0, 0, 0, 0), bg.border = NA) t2 = ccGenomicIdeogram(cytoband = cytoband) highlight.chromosome(paste0(\"human_chr\", c(1:22, \"X\", \"Y\")), col = \"red\", track.index = 1) highlight.chromosome(paste0(\"mouse_chr\", c(1:19, \"X\", \"Y\")), col = \"blue\", track.index = 1) # a track of points human_df = generateRandomBed(200, species = \"hg19\") mouse_df = generateRandomBed(200, species = \"mm10\") human_df[ ,1] = paste0(\"human_\", human_df[, 1]) mouse_df[ ,1] = paste0(\"mouse_\", mouse_df[, 1]) df = rbind(human_df, mouse_df) t3 = ccGenomicTrack(df, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, col = rand_color(1), cex = 0.5, ...) }) # links between human and mouse genomes human_mid = data.frame( chr = paste0(\"human_chr\", 1:19), mid = round((human_chromInfo[1:19, 2] + human_chromInfo[1:19, 3])/2) ) mouse_mid = data.frame( chr = paste0(\"mouse_chr\", 1:19), mid = round((mouse_chromInfo[1:19, 2] + mouse_chromInfo[1:19, 3])/2) ) l1 = ccGenomicLink(human_mid, mouse_mid, col = rand_color(19)) cc + par1 + t1 + t2 + t3 + l1 circos.clear() text(-0.9, -0.8, \"Human\\ngenome\") text(0.9, 0.8, \"Mouse\\ngenome\") The combined genome with more tracks.","title":"Concatenating two genomes"},{"location":"10-create-plotting-regions/","text":"Create plotting regions for genomic data Links set.seed(123) bed1 = generateRandomBed(nr = 100) bed1 = bed1[sample(nrow(bed1), 20), ] bed2 = generateRandomBed(nr = 100) bed2 = bed2[sample(nrow(bed2), 20), ] cc = ccPlot(initFunc = \"initializeWithIdeogram\") l1 =ccGenomicLink(bed1, bed2, col = rand_color(nrow(bed1), transparency = 0.5), border = NA) cc + l1 Add links from two sets of genomic regions. circos.clear()","title":"Create plotting regions for genomic data"},{"location":"10-create-plotting-regions/#create-plotting-regions-for-genomic-data","text":"","title":"Create plotting regions for genomic data"},{"location":"10-create-plotting-regions/#links","text":"set.seed(123) bed1 = generateRandomBed(nr = 100) bed1 = bed1[sample(nrow(bed1), 20), ] bed2 = generateRandomBed(nr = 100) bed2 = bed2[sample(nrow(bed2), 20), ] cc = ccPlot(initFunc = \"initializeWithIdeogram\") l1 =ccGenomicLink(bed1, bed2, col = rand_color(nrow(bed1), transparency = 0.5), border = NA) cc + l1 Add links from two sets of genomic regions. circos.clear()","title":"Links"},{"location":"11-modes-of-input/","text":"Modes for circos.genomicTrack() Applications Points set.seed(999) par1 = ccPar(\"track.height\" = 0.1, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) cc = ccPlot(initFunc = \"initializeWithIdeogram\",chromosome.index = \"chr1\", plotType = NULL) bed = generateRandomBed(nr = 300) t1 = ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...) }) t2 = ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5,...) i = getI(...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = \"#00000040\") }) bed1 = generateRandomBed(nr = 300) bed2 = generateRandomBed(nr = 300) bed_list = list(bed1, bed2) t3 = ccGenomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) }) t4 = ccGenomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = \"#00000040\") }) bed = generateRandomBed(nr = 300, nc = 4) t5 = ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = 1:4, ...) }) bed = generateRandomBed(nr = 300, nc = 4) t6 = ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = \"#00000040\") }) cc + par1 + t1 + t2 + t3 + t4 + t5 + t6 circos.clear() Add points under different modes. Lines par1 = ccPar(\"track.height\" = 0.08, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = \"chr1\", plotType = NULL) bed = generateRandomBed(nr = 500) t1 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value) }) t2 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, area = TRUE) }) t3 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = \"h\") }) bed1 = generateRandomBed(nr = 500) bed2 = generateRandomBed(nr = 500) bed_list = list(bed1, bed2) t4 =ccGenomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) t5 =ccGenomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) bed = generateRandomBed(nr = 500, nc = 4) t6 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, col = 1:4, ...) }) bed = generateRandomBed(nr = 500, nc = 4) t7 =ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) bed = generateRandomBed(nr = 200) t8 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = \"segment\", lwd = 2, col = rand_color(nrow(region)), ...) }) cc + par1 + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 circos.clear() Add lines under different modes. Rectangles par1 = ccPar(\"track.height\" = 0.15, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = \"chr1\", plotType = NULL) col_fun = colorRamp2(breaks = c(-1, 0, 1), colors = c(\"green\", \"black\", \"red\")) bed = generateRandomBed(nr = 100, nc = 4) t1 = ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, col = col_fun(value[[1]]), border = NA, ...) }) bed1 = generateRandomBed(nr = 100) bed2 = generateRandomBed(nr = 100) bed_list = list(bed1, bed2) t2 = ccGenomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.3, ybottom = i - 0.3, col = col_fun(value[[1]]), ...) }) t3 = ccGenomicTrack(bed_list, ylim = c(0.5, 2.5), panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.3, ybottom = i - 0.3, col = col_fun(value[[1]]), ...) }) bed = generateRandomBed(nr = 200) t4 = ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, col = ifelse(value[[1]] > 0, \"red\", \"green\"), ...) circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"#00000040\") }) cc + par1 + t1 + t2 + t3 + t4 circos.clear() Add rectangles under different modes.","title":"Modes for circos.genomicTrack()"},{"location":"11-modes-of-input/#modes-for-circosgenomictrack","text":"","title":"Modes for circos.genomicTrack()"},{"location":"11-modes-of-input/#applications","text":"","title":"Applications"},{"location":"11-modes-of-input/#points","text":"set.seed(999) par1 = ccPar(\"track.height\" = 0.1, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) cc = ccPlot(initFunc = \"initializeWithIdeogram\",chromosome.index = \"chr1\", plotType = NULL) bed = generateRandomBed(nr = 300) t1 = ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...) }) t2 = ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5,...) i = getI(...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = \"#00000040\") }) bed1 = generateRandomBed(nr = 300) bed2 = generateRandomBed(nr = 300) bed_list = list(bed1, bed2) t3 = ccGenomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) }) t4 = ccGenomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = \"#00000040\") }) bed = generateRandomBed(nr = 300, nc = 4) t5 = ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = 1:4, ...) }) bed = generateRandomBed(nr = 300, nc = 4) t6 = ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = \"#00000040\") }) cc + par1 + t1 + t2 + t3 + t4 + t5 + t6 circos.clear() Add points under different modes.","title":"Points"},{"location":"11-modes-of-input/#lines","text":"par1 = ccPar(\"track.height\" = 0.08, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = \"chr1\", plotType = NULL) bed = generateRandomBed(nr = 500) t1 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value) }) t2 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, area = TRUE) }) t3 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = \"h\") }) bed1 = generateRandomBed(nr = 500) bed2 = generateRandomBed(nr = 500) bed_list = list(bed1, bed2) t4 =ccGenomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) t5 =ccGenomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) bed = generateRandomBed(nr = 500, nc = 4) t6 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, col = 1:4, ...) }) bed = generateRandomBed(nr = 500, nc = 4) t7 =ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) bed = generateRandomBed(nr = 200) t8 =ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = \"segment\", lwd = 2, col = rand_color(nrow(region)), ...) }) cc + par1 + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 circos.clear() Add lines under different modes.","title":"Lines"},{"location":"11-modes-of-input/#rectangles","text":"par1 = ccPar(\"track.height\" = 0.15, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = \"chr1\", plotType = NULL) col_fun = colorRamp2(breaks = c(-1, 0, 1), colors = c(\"green\", \"black\", \"red\")) bed = generateRandomBed(nr = 100, nc = 4) t1 = ccGenomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, col = col_fun(value[[1]]), border = NA, ...) }) bed1 = generateRandomBed(nr = 100) bed2 = generateRandomBed(nr = 100) bed_list = list(bed1, bed2) t2 = ccGenomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.3, ybottom = i - 0.3, col = col_fun(value[[1]]), ...) }) t3 = ccGenomicTrack(bed_list, ylim = c(0.5, 2.5), panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.3, ybottom = i - 0.3, col = col_fun(value[[1]]), ...) }) bed = generateRandomBed(nr = 200) t4 = ccGenomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, col = ifelse(value[[1]] > 0, \"red\", \"green\"), ...) circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = \"#00000040\") }) cc + par1 + t1 + t2 + t3 + t4 circos.clear() Add rectangles under different modes.","title":"Rectangles"},{"location":"12-high-level-genomic-functions/","text":"High-level genomic functions Ideograms cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = c(\"labels\", \"axis\")) t1 = ccTrack(ylim = c(0, 1)) t2 =ccGenomicIdeogram() # put ideogram as the third track t3 = ccGenomicIdeogram(track.height = 0.2) cc + t1 + t2 + t3 Circular ideograms. Heatmaps cc = ccPlot(initFunc = \"initializeWithIdeogram\") bed = generateRandomBed(nr = 100, nc = 4) col_fun = colorRamp2(c(-1, 0, 1), c(\"green\", \"black\", \"red\")) t1 = ccGenomicHeatmap(bed, col = col_fun, side = \"inside\", border = \"white\") cc + t1 circos.clear() cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = NULL) t1 = ccGenomicHeatmap(bed, col = col_fun, side = \"outside\", line_col = as.numeric(factor(bed[[1]]))) t2 = ccGenomicIdeogram() cc + t1 + t2 circos.clear() Genomic heamtaps. Labels cc = ccPlot(initFunc = \"initializeWithIdeogram\") bed = generateRandomBed(nr = 50, fun = function(k) sample(letters, k, replace = TRUE)) bed[1, 4] = \"aaaaa\" t1 = ccGenomicLabels(bed, labels.column = 4, side = \"inside\") cc + t1 circos.clear() cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = NULL) t1 = ccGenomicLabels(bed, labels.column = 4, side = \"outside\", col = as.numeric(factor(bed[[1]])), line_col = as.numeric(factor(bed[[1]]))) t2 = ccGenomicIdeogram() cc + t1 + t2 circos.clear() Genomic labels. Genomic axes cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = c(\"axis\")) t1 = ccGenomicIdeogram() t2 = ccTrack(ylim = c(0, 1), track.height = 0.1, panel.fun = function(x, y) { circos.genomicAxis(h = \"bottom\", direction = \"inside\") }) cc + t1 + t2 Add genomic axes. circos.clear() Genomic density and Rainfall plot load(system.file(package = \"circlize\", \"extdata\", \"DMR.RData\")) cc = ccPlot(initFunc=\"initializeWithIdeogram\", chromosome.index = paste0(\"chr\", 1:22)) bed_list = list(DMR_hyper, DMR_hypo) t1 = ccGenomicRainfall(bed_list, pch = 16, cex = 0.4, col = c(\"#FF000080\", \"#0000FF80\")) t2 = ccGenomicDensity(DMR_hyper, col = c(\"#FF000080\"), track.height = 0.1) t3 = ccGenomicDensity(DMR_hypo, col = c(\"#0000FF80\"), track.height = 0.1) cc + t1 + t2 + t3 Genomic rainfall plot and densities. circos.clear() cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = paste0(\"chr\", 1:22)) t1 = ccGenomicDensity(DMR_hyper, col = c(\"#FF000080\"), track.height = 0.1) t2 = ccGenomicDensity(DMR_hyper, col = c(\"#FF000080\"), count_by = \"number\", track.height = 0.1) cc + t1 + t2 Genomic densities. circos.clear()","title":"High-level genomic functions"},{"location":"12-high-level-genomic-functions/#high-level-genomic-functions","text":"","title":"High-level genomic functions"},{"location":"12-high-level-genomic-functions/#ideograms","text":"cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = c(\"labels\", \"axis\")) t1 = ccTrack(ylim = c(0, 1)) t2 =ccGenomicIdeogram() # put ideogram as the third track t3 = ccGenomicIdeogram(track.height = 0.2) cc + t1 + t2 + t3 Circular ideograms.","title":"Ideograms"},{"location":"12-high-level-genomic-functions/#heatmaps","text":"cc = ccPlot(initFunc = \"initializeWithIdeogram\") bed = generateRandomBed(nr = 100, nc = 4) col_fun = colorRamp2(c(-1, 0, 1), c(\"green\", \"black\", \"red\")) t1 = ccGenomicHeatmap(bed, col = col_fun, side = \"inside\", border = \"white\") cc + t1 circos.clear() cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = NULL) t1 = ccGenomicHeatmap(bed, col = col_fun, side = \"outside\", line_col = as.numeric(factor(bed[[1]]))) t2 = ccGenomicIdeogram() cc + t1 + t2 circos.clear() Genomic heamtaps.","title":"Heatmaps"},{"location":"12-high-level-genomic-functions/#labels","text":"cc = ccPlot(initFunc = \"initializeWithIdeogram\") bed = generateRandomBed(nr = 50, fun = function(k) sample(letters, k, replace = TRUE)) bed[1, 4] = \"aaaaa\" t1 = ccGenomicLabels(bed, labels.column = 4, side = \"inside\") cc + t1 circos.clear() cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = NULL) t1 = ccGenomicLabels(bed, labels.column = 4, side = \"outside\", col = as.numeric(factor(bed[[1]])), line_col = as.numeric(factor(bed[[1]]))) t2 = ccGenomicIdeogram() cc + t1 + t2 circos.clear() Genomic labels.","title":"Labels"},{"location":"12-high-level-genomic-functions/#genomic-axes","text":"cc = ccPlot(initFunc = \"initializeWithIdeogram\", plotType = c(\"axis\")) t1 = ccGenomicIdeogram() t2 = ccTrack(ylim = c(0, 1), track.height = 0.1, panel.fun = function(x, y) { circos.genomicAxis(h = \"bottom\", direction = \"inside\") }) cc + t1 + t2 Add genomic axes. circos.clear()","title":"Genomic axes"},{"location":"12-high-level-genomic-functions/#genomic-density-and-rainfall-plot","text":"load(system.file(package = \"circlize\", \"extdata\", \"DMR.RData\")) cc = ccPlot(initFunc=\"initializeWithIdeogram\", chromosome.index = paste0(\"chr\", 1:22)) bed_list = list(DMR_hyper, DMR_hypo) t1 = ccGenomicRainfall(bed_list, pch = 16, cex = 0.4, col = c(\"#FF000080\", \"#0000FF80\")) t2 = ccGenomicDensity(DMR_hyper, col = c(\"#FF000080\"), track.height = 0.1) t3 = ccGenomicDensity(DMR_hypo, col = c(\"#0000FF80\"), track.height = 0.1) cc + t1 + t2 + t3 Genomic rainfall plot and densities. circos.clear() cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = paste0(\"chr\", 1:22)) t1 = ccGenomicDensity(DMR_hyper, col = c(\"#FF000080\"), track.height = 0.1) t2 = ccGenomicDensity(DMR_hyper, col = c(\"#FF000080\"), count_by = \"number\", track.height = 0.1) cc + t1 + t2 Genomic densities. circos.clear()","title":"Genomic density and Rainfall plot"},{"location":"13-nested-zooming/","text":"Nested zooming Basic idea set.seed(123) df = data.frame(cate = sample(letters[1:8], 400, replace = TRUE), x = runif(400), y = runif(400), stringsAsFactors = FALSE) df = df[order(df[[1]], df[[2]]), ] rownames(df) = NULL df$interval_x = as.character(cut(df$x, c(0, 0.2, 0.4, 0.6, 0.8, 1.0))) df$name = paste(df$cate, df$interval_x, sep = \":\") df$start = as.numeric(gsub(\"^\\\\((\\\\d(\\\\.\\\\d)?).*(\\\\d(\\\\.\\\\d)?)]\", \"\\\\1\", df$interval_x)) df$end = as.numeric(gsub(\"^\\\\((\\\\d(\\\\.\\\\d)?),(\\\\d(\\\\.\\\\d)?)]$\", \"\\\\3\", df$interval_x)) nm = sample(unique(df$name), 20) df2 = df[df$name %in% nm, ] correspondance = unique(df2[, c(\"cate\", \"start\", \"end\", \"name\", \"start\", \"end\")]) zoom_sector = unique(df2[, c(\"name\", \"start\", \"end\", \"cate\")]) zoom_data = df2[, c(\"name\", \"x\", \"y\")] data = df[, 1:3] sector = data.frame(cate = letters[1:8], start = 0, end = 1, stringsAsFactors = FALSE) sector_col = structure(rand_color(8, transparency = 0.5), names = letters[1:8]) circos.clear() f1 = function() { par1 = ccPar(gap.degree = 10) cc = ccPlot(sectors = sector[, 1], xlim = sector[, 2:3], clear = FALSE) t1 = ccTrack(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5, col = \"red\") }) show(cc + par1 + t1) } f2 = function() { par1 = ccPar(gap.degree = 2, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3]), clear = FALSE) t1 = ccTrack(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) show(cc + par1 + t1) } circos.nested(f1, f2, correspondance) Nested zooming between two circular plots. circos.nested(f2, f1, correspondance[, c(4:6, 1:3)]) Nested zooming between two circular plots, zoomed plot is put outside. sector_col = structure(rand_color(8, transparency = 0.5), names = letters[1:8]) circos.clear() f1 = function() { par1 = ccPar(gap.degree = 10) cc = ccPlot(sectors = sector[, 1], xlim = sector[, 2:3], clear = FALSE) t1 = ccTrack(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), panel.fun = function(x, y) { l = correspondance[[1]] == CELL_META$sector.index if(sum(l)) { for(i in which(l)) { circos.rect(correspondance[i, 2], CELL_META$cell.ylim[1], correspondance[i, 3], CELL_META$cell.ylim[2], col = sector_col[CELL_META$sector.index], border = sector_col[CELL_META$sector.index]) } } circos.points(x, y, pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), CELL_META$sector.index, niceFacing = TRUE, adj = c(0.5, 0)) }) show(cc + par1 + t1) } f2 = function() { par1 = ccPar(gap.degree = 2, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3]), clear = FALSE) t1 = ccTrack(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }, bg.col = sector_col[zoom_sector$cate], track.margin = c(0, 0)) show(cc + par1 + t1) } circos.nested(f1, f2, correspondance, connection_col = sector_col[correspondance[[1]]]) Nested zooming between two circular plots, slightly complex plots. Visualization of DMRs from tagmentation-based WGBS load(system.file(package = \"circlize\", \"extdata\", \"tagments_WGBS_DMR.RData\")) circos.clear() chr_bg_color = rand_color(22, transparency = 0.8) names(chr_bg_color) = paste0(\"chr\", 1:22) f1 = function() { par1 = ccPar(gap.after = 2, start.degree = 90) cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = paste0(\"chr\", 1:22), plotType = c(\"ideogram\", \"labels\"), ideogram.height = 0.03, clear = FALSE) show(cc + par1) } f2 = function() { par1 = ccPar(cell.padding = c(0, 0, 0, 0), gap.after = c(rep(1, nrow(tagments)-1), 10)) cc = ccPlot(initFunc = \"genomicInitialize\",data = tagments, plotType = NULL, clear = FALSE) t1 = ccGenomicTrack(DMR1, ylim = c(-0.6, 0.6), panel.fun = function(region, value, ...) { for(h in seq(-0.6, 0.6, by = 0.2)) { circos.lines(CELL_META$cell.xlim, c(h, h), lty = 3, col = \"#AAAAAA\") } circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 3, col = \"#888888\") circos.genomicPoints(region, value, col = ifelse(value[[1]] > 0, \"#E41A1C\", \"#377EB8\"), pch = 16, cex = 0.5) }, bg.col = chr_bg_color[tagments$chr], track.margin = c(0.02, 0)) c1 = ccCell(sector.index = \"chr1-44876009-45016546\") y1 = ccYaxis(side = \"left\", at = seq(-0.6, 0.6, by = 0.3), labels.cex = 0.4) t2 = ccTrack(ylim = c(0, 1), track.height = mm_h(2), bg.col = add_transparency(chr_bg_color[tagments$chr], 0)) c1 = c1 + y1 t1 = t1 + c1 show(cc + par1 + t1 + t2) } circos.nested(f1, f2, correspondance, connection_col = chr_bg_color[correspondance[[1]]]) Visualization of DMRs.","title":"Nested zooming"},{"location":"13-nested-zooming/#nested-zooming","text":"","title":"Nested zooming"},{"location":"13-nested-zooming/#basic-idea","text":"set.seed(123) df = data.frame(cate = sample(letters[1:8], 400, replace = TRUE), x = runif(400), y = runif(400), stringsAsFactors = FALSE) df = df[order(df[[1]], df[[2]]), ] rownames(df) = NULL df$interval_x = as.character(cut(df$x, c(0, 0.2, 0.4, 0.6, 0.8, 1.0))) df$name = paste(df$cate, df$interval_x, sep = \":\") df$start = as.numeric(gsub(\"^\\\\((\\\\d(\\\\.\\\\d)?).*(\\\\d(\\\\.\\\\d)?)]\", \"\\\\1\", df$interval_x)) df$end = as.numeric(gsub(\"^\\\\((\\\\d(\\\\.\\\\d)?),(\\\\d(\\\\.\\\\d)?)]$\", \"\\\\3\", df$interval_x)) nm = sample(unique(df$name), 20) df2 = df[df$name %in% nm, ] correspondance = unique(df2[, c(\"cate\", \"start\", \"end\", \"name\", \"start\", \"end\")]) zoom_sector = unique(df2[, c(\"name\", \"start\", \"end\", \"cate\")]) zoom_data = df2[, c(\"name\", \"x\", \"y\")] data = df[, 1:3] sector = data.frame(cate = letters[1:8], start = 0, end = 1, stringsAsFactors = FALSE) sector_col = structure(rand_color(8, transparency = 0.5), names = letters[1:8]) circos.clear() f1 = function() { par1 = ccPar(gap.degree = 10) cc = ccPlot(sectors = sector[, 1], xlim = sector[, 2:3], clear = FALSE) t1 = ccTrack(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5, col = \"red\") }) show(cc + par1 + t1) } f2 = function() { par1 = ccPar(gap.degree = 2, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3]), clear = FALSE) t1 = ccTrack(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) show(cc + par1 + t1) } circos.nested(f1, f2, correspondance) Nested zooming between two circular plots. circos.nested(f2, f1, correspondance[, c(4:6, 1:3)]) Nested zooming between two circular plots, zoomed plot is put outside. sector_col = structure(rand_color(8, transparency = 0.5), names = letters[1:8]) circos.clear() f1 = function() { par1 = ccPar(gap.degree = 10) cc = ccPlot(sectors = sector[, 1], xlim = sector[, 2:3], clear = FALSE) t1 = ccTrack(data[[1]], x = data[[2]], y = data[[3]], ylim = c(0, 1), panel.fun = function(x, y) { l = correspondance[[1]] == CELL_META$sector.index if(sum(l)) { for(i in which(l)) { circos.rect(correspondance[i, 2], CELL_META$cell.ylim[1], correspondance[i, 3], CELL_META$cell.ylim[2], col = sector_col[CELL_META$sector.index], border = sector_col[CELL_META$sector.index]) } } circos.points(x, y, pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(2), CELL_META$sector.index, niceFacing = TRUE, adj = c(0.5, 0)) }) show(cc + par1 + t1) } f2 = function() { par1 = ccPar(gap.degree = 2, cell.padding = c(0, 0, 0, 0)) cc = ccPlot(sectors = zoom_sector[[1]], xlim = as.matrix(zoom_sector[, 2:3]), clear = FALSE) t1 = ccTrack(zoom_data[[1]], x = zoom_data[[2]], y = zoom_data[[3]], panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }, bg.col = sector_col[zoom_sector$cate], track.margin = c(0, 0)) show(cc + par1 + t1) } circos.nested(f1, f2, correspondance, connection_col = sector_col[correspondance[[1]]]) Nested zooming between two circular plots, slightly complex plots.","title":"Basic idea"},{"location":"13-nested-zooming/#visualization-of-dmrs-from-tagmentation-based-wgbs","text":"load(system.file(package = \"circlize\", \"extdata\", \"tagments_WGBS_DMR.RData\")) circos.clear() chr_bg_color = rand_color(22, transparency = 0.8) names(chr_bg_color) = paste0(\"chr\", 1:22) f1 = function() { par1 = ccPar(gap.after = 2, start.degree = 90) cc = ccPlot(initFunc = \"initializeWithIdeogram\", chromosome.index = paste0(\"chr\", 1:22), plotType = c(\"ideogram\", \"labels\"), ideogram.height = 0.03, clear = FALSE) show(cc + par1) } f2 = function() { par1 = ccPar(cell.padding = c(0, 0, 0, 0), gap.after = c(rep(1, nrow(tagments)-1), 10)) cc = ccPlot(initFunc = \"genomicInitialize\",data = tagments, plotType = NULL, clear = FALSE) t1 = ccGenomicTrack(DMR1, ylim = c(-0.6, 0.6), panel.fun = function(region, value, ...) { for(h in seq(-0.6, 0.6, by = 0.2)) { circos.lines(CELL_META$cell.xlim, c(h, h), lty = 3, col = \"#AAAAAA\") } circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 3, col = \"#888888\") circos.genomicPoints(region, value, col = ifelse(value[[1]] > 0, \"#E41A1C\", \"#377EB8\"), pch = 16, cex = 0.5) }, bg.col = chr_bg_color[tagments$chr], track.margin = c(0.02, 0)) c1 = ccCell(sector.index = \"chr1-44876009-45016546\") y1 = ccYaxis(side = \"left\", at = seq(-0.6, 0.6, by = 0.3), labels.cex = 0.4) t2 = ccTrack(ylim = c(0, 1), track.height = mm_h(2), bg.col = add_transparency(chr_bg_color[tagments$chr], 0)) c1 = c1 + y1 t1 = t1 + c1 show(cc + par1 + t1 + t2) } circos.nested(f1, f2, correspondance, connection_col = chr_bg_color[correspondance[[1]]]) Visualization of DMRs.","title":"Visualization of DMRs from tagmentation-based WGBS"}]}